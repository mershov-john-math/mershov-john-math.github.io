<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Duck's Roguelike Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c; /* gray-900 */
            color: #f7fafc; /* gray-100 */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }

        canvas {
            background-color: #2d3748; /* gray-800 */
            border: 4px solid #4a5568; /* gray-700 */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            padding: 0 1rem;
            font-size: 0.9rem;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #2d3748; /* gray-800 */
            padding: 2rem;
            border: 4px solid #4a5568; /* gray-700 */
            text-align: center;
            max-width: 90%;
            width: 600px;
        }
        
        .item-card {
            background-color: #4a5568; /* gray-700 */
            border: 2px solid #718096; /* gray-600 */
            padding: 1rem;
            margin: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .item-card:hover {
            background-color: #718096; /* gray-600 */
            border-color: #a0aec0; /* gray-500 */
            transform: translateY(-5px);
        }

        .button {
            background-color: #4299e1; /* blue-500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            text-transform: uppercase;
            margin-top: 1rem;
        }
        .button:hover {
            background-color: #3182ce; /* blue-600 */
        }
    </style>
</head>

<body>
    <div id="game-container" class="game-container">
        <div id="hud">
            <div id="health-container">Health: <span id="health">100 / 100</span></div>
            <div id="floor-container">Floor: <span id="floor">1</span></div>
            <div id="inventory-container">Inventory: <span id="inventory"></span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="start-screen" class="modal">
        <div class="modal-content">
            <h1 class="text-3xl mb-4">Weather Duck's Adventure</h1>
            <p class="mb-6">IMT Lazarus has stolen the weather! Help the Weather Duck get it back.</p>
            <p class="mb-2 text-sm">WASD to Move</p>
            <p class="mb-6 text-sm">Arrow Keys to Shoot</p>
            <button id="start-button" class="button">Start Game</button>
        </div>
    </div>

    <div id="item-selection-screen" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl mb-4">Floor Cleared! Choose an Upgrade.</h2>
            <div id="item-choices" class="grid md:grid-cols-3 gap-4"></div>
        </div>
    </div>
    
    <div id="game-over-screen" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-3xl mb-4 text-red-500">GAME OVER</h2>
            <p class="mb-6">The weather remains in the clutches of IMT Lazarus...</p>
            <button id="restart-button" class="button">Try Again</button>
        </div>
    </div>

    <div id="win-screen" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-3xl mb-4 text-yellow-400">YOU WIN!</h2>
            <p class="mb-6">You defeated IMT Lazarus and restored the weather! The world is soggy and grateful.</p>
            <button id="play-again-button" class="button">Play Again</button>
        </div>
    </div>

    <div id="post-boss-screen" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-3xl mb-4 text-yellow-400">IMT Lazarus Defeated!</h2>
            <p class="mb-6">You have restored balance to the weather, but a strange power still emanates from the dungeon... Do you retire a hero, or press onward into the unknown?</p>
            <div class="flex justify-center gap-4">
                <button id="finish-game-button" class="button">Finish Game</button>
                <button id="continue-game-button" class="button">Continue Adventure</button>
            </div>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const hud = {
            health: document.getElementById('health'),
            floor: document.getElementById('floor'),
            inventory: document.getElementById('inventory')
        };
        const startScreen = document.getElementById('start-screen');
        const itemSelectionScreen = document.getElementById('item-selection-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        const postBossScreen = document.getElementById('post-boss-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const playAgainButton = document.getElementById('play-again-button');
        const finishGameButton = document.getElementById('finish-game-button');
        const continueGameButton = document.getElementById('continue-game-button');
        
        // Game Constants
        const PLAYER_SIZE = 30;
        const ENEMY_SIZE = 30;
        const BULLET_SIZE = 10;
        const ROOM_PADDING = 50;
        const DOOR_WIDTH = 80;
        const DOOR_THICKNESS = 10;
        
        let gameState = 'start'; // 'start', 'playing', 'item_selection', 'game_over', 'win'

        // Game State
        let player, enemies, bullets, enemyBullets, floor, keys, lastShotTime, doors, endlessMode, explosions;

        // --- Item Definitions ---
        const ITEMS = [
            // Stat increases
            { name: 'Featherlight Boots', description: '+20% Speed', type: 'stat', effect: p => p.speed *= 1.2 },
            { name: 'Heavy Raincoat', description: '+25 Max Health', type: 'stat', effect: p => { p.maxHealth += 25; p.health += 25; }},
            { name: 'Stronger Wings', description: '+20% Damage', type: 'stat', effect: p => p.damage *= 1.2 },
            { name: 'Rapid-Fire Beak', description: '-20% Fire Delay', type: 'stat', effect: p => p.fireRate *= 0.8 },
            { name: 'Lucky Clover', description: '+10% Crit Chance', type: 'stat', effect: p => p.critChance += 0.1 },
            { name: 'Sharpened Beak', description: '+50% Crit Damage', type: 'stat', effect: p => p.critDamage += 0.5 },

            // Bullet effects
            { name: 'Thunderstorm', description: 'Bullets may chain lightning to nearby enemies.', type: 'bullet_effect', effect: p => p.bulletEffects.push('thunderstorm') },
            { name: 'Blizzard', description: 'Bullets have a chance to freeze enemies.', type: 'bullet_effect', effect: p => p.bulletEffects.push('blizzard') },
            { name: 'Ricochet Rain', description: 'Bullets bounce off walls once.', type: 'bullet_effect', effect: p => p.bulletEffects.push('ricochet') },
            { name: 'Homing Missiles', description: 'Bullets will seek out nearby enemies.', type: 'bullet_effect', effect: p => p.bulletEffects.push('homing') },
            { name: 'Piercing Rounds', description: 'Bullets can pierce through one enemy.', type: 'bullet_effect', effect: p => p.bulletEffects.push('piercing') },
            { name: 'Gravity Well', description: 'Bullets temporarily slow enemies on hit.', type: 'bullet_effect', effect: p => p.bulletEffects.push('gravity_well') },
            { name: 'Unstable Ordinance', description: 'Bullets have a 20% chance to explode on impact.', type: 'bullet_effect', effect: p => p.bulletEffects.push('unstable_ordinance') },
            
            // Math functions
            { name: 'Sine Wave Shot', description: 'Bullets travel in a sine wave pattern.', type: 'bullet_effect', effect: p => p.bulletEffects.push('sine_wave') },
            { name: 'Logarithmic Decay', description: 'Bullets shrink over their lifetime.', type: 'bullet_effect', effect: p => p.bulletEffects.push('log_decay') },
            { name: 'Exponential Growth', description: 'Bullets grow over their lifetime.', type: 'bullet_effect', effect: p => p.bulletEffects.push('exponential') },

            // Specials
            { name: 'Tangent Shot', description: 'Fire two additional bullets at slight angles.', type: 'special', effect: p => p.bulletEffects.push('tangent') },
            { name: 'Fibonacci Spiral', description: 'Fire a spiral of bullets occasionally.', type: 'special', effect: p => p.bulletEffects.push('fibonacci') },
        ];

        const ENDLESS_ITEMS = [
            { name: 'Gale Force Wings', description: '+50% Damage', type: 'stat', effect: p => p.damage *= 1.5 },
            { name: 'Storm God\'s Armor', description: '+100 Max Health', type: 'stat', effect: p => { p.maxHealth += 100; p.health += 100; }},
            { name: 'Hyper-Velocity Beak', description: '-30% Fire Delay', type: 'stat', effect: p => p.fireRate *= 0.7 },
            { name: 'Eye of the Hurricane', description: 'Fire bullets in 4 directions.', type: 'special', effect: p => p.bulletEffects.push('hurricane') },
            { name: 'Absolute Zero', description: 'Blizzard freeze is now permanent on non-bosses.', type: 'bullet_effect', effect: p => p.bulletEffects.push('absolute_zero') },
        ];


        // --- Initialization ---
        function init() {
            canvas.width = 800;
            canvas.height = 600;

            player = {
                x: canvas.width / 2 - PLAYER_SIZE / 2,
                y: canvas.height / 2 - PLAYER_SIZE / 2,
                width: PLAYER_SIZE,
                height: PLAYER_SIZE,
                speed: 250, // pixels per second
                health: 100,
                maxHealth: 100,
                damage: 10,
                fireRate: 500, // ms between shots
                critChance: 0.05,
                critDamage: 1.5,
                bulletEffects: [],
                inventory: [],
                invincible: false,
                invincibilityEndTime: 0
            };

            floor = 0;
            keys = {};
            lastShotTime = 0;
            endlessMode = false;
            explosions = [];
            
            nextLevel();
        }

        function nextLevel() {
            floor++;
            player.x = canvas.width / 2 - PLAYER_SIZE / 2;
            player.y = canvas.height - ROOM_PADDING - PLAYER_SIZE - 20;
            
            // Give player invincibility at the start of a new floor
            player.invincible = true;
            player.invincibilityEndTime = Date.now() + 3000; // 3 seconds

            generateRoom();
            gameState = 'playing';
            updateHUD();
        }
        
        function generateRoom() {
            enemies = [];
            bullets = [];
            enemyBullets = [];
            explosions = [];
            let enemyCount = Math.floor(2 + floor * 1.5);
            if (endlessMode) {
                enemyCount = Math.floor(enemyCount * 1.5);
            }
            
            if (floor % 5 === 0) { // Boss floor
                enemies.push(createBoss());
            } else {
                for (let i = 0; i < enemyCount; i++) {
                    let x, y;
                    do {
                        x = ROOM_PADDING + Math.random() * (canvas.width - ROOM_PADDING * 2 - ENEMY_SIZE);
                        y = ROOM_PADDING + Math.random() * (canvas.height - ROOM_PADDING * 2 - ENEMY_SIZE);
                    } while (Math.hypot(x - player.x, y - player.y) < 200); // Don't spawn on top of player
                    
                    // Add a chance for ranged enemies after floor 3
                    if (floor > 3 && Math.random() < 0.3) {
                        enemies.push(createRangedEnemy(x, y));
                    } else {
                        enemies.push(createEnemy(x, y));
                    }
                }
            }

            doors = [
                { x: canvas.width / 2 - DOOR_WIDTH / 2, y: ROOM_PADDING, width: DOOR_WIDTH, height: DOOR_THICKNESS, open: false, side: 'top' },
                { x: canvas.width / 2 - DOOR_WIDTH / 2, y: canvas.height - ROOM_PADDING - DOOR_THICKNESS, width: DOOR_WIDTH, height: DOOR_THICKNESS, open: false, side: 'bottom' },
                { x: ROOM_PADDING, y: canvas.height / 2 - DOOR_WIDTH / 2, width: DOOR_THICKNESS, height: DOOR_WIDTH, open: false, side: 'left' },
                { x: canvas.width - ROOM_PADDING - DOOR_THICKNESS, y: canvas.height / 2 - DOOR_WIDTH / 2, width: DOOR_THICKNESS, height: DOOR_WIDTH, open: false, side: 'right' },
            ];
        }

        // --- Update Functions ---

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState !== 'playing') return;
            
            const deltaTime = (timestamp - lastTime) / 1000 || 0;
            lastTime = timestamp;

            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            updateEnemies(deltaTime);
            updateEnemyBullets(deltaTime);
            updateExplosions(deltaTime);
            checkCollisions();

            draw();

            requestAnimationFrame(gameLoop);
        }

        function updatePlayer(dt) {
            // Check for invincibility timeout
            if (player.invincible && Date.now() > player.invincibilityEndTime) {
                player.invincible = false;
            }

            // DEBUG: Kill all enemies
            if (keys['k']) {
                enemies = [];
                keys['k'] = false; // Reset key to prevent this from running every frame
            }

            let dx = 0;
            let dy = 0;
            if (keys['w']) dy -= 1;
            if (keys['s']) dy += 1;
            if (keys['a']) dx -= 1;
            if (keys['d']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const mag = Math.sqrt(dx * dx + dy * dy);
                dx /= mag;
                dy /= mag;
                
                player.x += dx * player.speed * dt;
                player.y += dy * player.speed * dt;
            }
            
            // Wall collision
            player.x = Math.max(ROOM_PADDING, Math.min(player.x, canvas.width - ROOM_PADDING - player.width));
            player.y = Math.max(ROOM_PADDING, Math.min(player.y, canvas.height - ROOM_PADDING - player.height));
            
            // Check for level clear
            if (enemies.length === 0 && gameState === 'playing') {
                doors.forEach(d => d.open = true);
                
                let enteredDoor = false;
                doors.forEach(d => {
                    if (player.x < d.x + d.width && player.x + player.width > d.x &&
                        player.y < d.y + d.height && player.y + player.height > d.y) {
                        enteredDoor = true;
                    }
                });

                if (enteredDoor) {
                    if (floor === 10 && !endlessMode) { 
                        winGame();
                        return; // return from updatePlayer
                    }
                    levelClear();
                }
            }
        }

        function updateBullets(dt) {
            // Shooting
            const now = Date.now();
            if (now - lastShotTime > player.fireRate) {
                let shootDir = { x: 0, y: 0 };
                if (keys['arrowup']) shootDir.y = -1;
                if (keys['arrowdown']) shootDir.y = 1;
                if (keys['arrowleft']) shootDir.x = -1;
                if (keys['arrowright']) shootDir.x = 1;

                if (shootDir.x !== 0 || shootDir.y !== 0) {
                    lastShotTime = now;
                    const baseAngle = Math.atan2(shootDir.y, shootDir.x);
                    
                    createBullet(player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2, baseAngle);

                    if (player.bulletEffects.includes('hurricane')) {
                        for(let i = 1; i < 4; i++) {
                            createBullet(player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2, baseAngle + i * Math.PI / 2);
                        }
                    }
                    
                    if (player.bulletEffects.includes('tangent')) {
                         createBullet(player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2, baseAngle + Math.PI / 8);
                         createBullet(player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2, baseAngle - Math.PI / 8);
                    }
                    if (player.bulletEffects.includes('fibonacci') && Math.random() < 0.1) {
                         for(let i=0; i<8; i++){
                            createBullet(player.x + PLAYER_SIZE / 2, player.y + PLAYER_SIZE / 2, baseAngle + i * (Math.PI / 4));
                         }
                    }
                }
            }
            
            // Move bullets
            bullets.forEach((b, index) => {
                b.lifetime += dt;

                if (player.bulletEffects.includes('sine_wave')) {
                    const perpAngle = b.angle + Math.PI / 2;
                    const offsetX = Math.cos(perpAngle) * Math.sin(b.lifetime * 15) * 5;
                    const offsetY = Math.sin(perpAngle) * Math.sin(b.lifetime * 15) * 5;
                    b.x += Math.cos(b.angle) * b.speed * dt + offsetX;
                    b.y += Math.sin(b.angle) * b.speed * dt + offsetY;
                } else {
                    b.x += Math.cos(b.angle) * b.speed * dt;
                    b.y += Math.sin(b.angle) * b.speed * dt;
                }
                
                if (player.bulletEffects.includes('log_decay')) {
                    b.size = Math.max(2, b.initialSize * (1 - Math.log1p(b.lifetime * 2)));
                }
                if (player.bulletEffects.includes('exponential')) {
                    b.size = Math.min(40, b.initialSize * Math.exp(b.lifetime * 0.5));
                }

                if (player.bulletEffects.includes('homing')) {
                    const closestEnemy = findClosestEnemy(b.x, b.y);
                    if (closestEnemy) {
                        const targetAngle = Math.atan2(closestEnemy.y - b.y, closestEnemy.x - b.x);
                        let angleDiff = targetAngle - b.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        b.angle += angleDiff * 2 * dt; // Adjust homing strength
                    }
                }


                // Remove bullets that go off-screen
                if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
                    bullets.splice(index, 1);
                }
            });
        }
        
        function updateEnemies(dt) {
            enemies.forEach(e => {
                if(e.frozenUntil && (Date.now() < e.frozenUntil || (player.bulletEffects.includes('absolute_zero') && !e.isBoss))) return;
                e.frozenUntil = null;

                let currentSpeed = e.speed;
                if (e.slowedUntil && Date.now() < e.slowedUntil) {
                    currentSpeed *= 0.5; // 50% slow
                } else {
                    e.slowedUntil = null;
                }

                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    e.x += (dx / dist) * currentSpeed * dt;
                    e.y += (dy / dist) * currentSpeed * dt;
                }

                // Add wall collision for enemies
                e.x = Math.max(ROOM_PADDING, Math.min(e.x, canvas.width - ROOM_PADDING - e.width));
                e.y = Math.max(ROOM_PADDING, Math.min(e.y, canvas.height - ROOM_PADDING - e.height));

                // Handle shooting for ranged enemies
                if (e.type === 'ranged' && Date.now() > e.lastShotTime + e.fireRate) {
                    e.lastShotTime = Date.now();
                    const angle = Math.atan2(player.y - e.y, player.x - e.x);
                    enemyBullets.push(createEnemyBullet(e.x + e.width / 2, e.y + e.height / 2, angle, e.damage));
                }
            });
        }
        
        function updateEnemyBullets(dt) {
            enemyBullets.forEach((b, index) => {
                b.x += Math.cos(b.angle) * b.speed * dt;
                b.y += Math.sin(b.angle) * b.speed * dt;

                // Remove bullets that go off-screen
                if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
                    enemyBullets.splice(index, 1);
                }
            });
        }
        
        function updateExplosions(dt) {
            explosions.forEach((exp, index) => {
                exp.lifetime -= dt;
                if (exp.lifetime <= 0) {
                    explosions.splice(index, 1);
                }
            });
        }
        
        function checkCollisions() {
             // Bullets with enemies
            bullets.forEach((bullet, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (bullet.x < enemy.x + enemy.width && bullet.x + bullet.size > enemy.x &&
                        bullet.y < enemy.y + enemy.height && bullet.y + bullet.size > enemy.y) {
                        
                        let isCrit = Math.random() < player.critChance;
                        let damageDealt = player.damage * (isCrit ? player.critDamage : 1);
                        enemy.health -= damageDealt;
                        
                        // Handle bullet effects on hit
                        if (player.bulletEffects.includes('blizzard') && Math.random() < 0.25) {
                            enemy.frozenUntil = Date.now() + 2000;
                        }
                        if (player.bulletEffects.includes('thunderstorm') && Math.random() < 0.3) {
                            chainLightning(enemy, 2);
                        }
                        if (player.bulletEffects.includes('gravity_well')) {
                            enemy.slowedUntil = Date.now() + 3000; // Slow for 3 seconds
                        }
                        if (player.bulletEffects.includes('unstable_ordinance') && Math.random() < 0.2) { // 20% chance to explode
                            createExplosion(bullet.x, bullet.y, 80, player.damage * 0.5); // 80px radius, 50% damage
                        }

                        if (!player.bulletEffects.includes('piercing') || bullet.pierced) {
                           bullets.splice(bIndex, 1);
                        } else {
                           bullet.pierced = true;
                        }

                        if (enemy.health <= 0) {
                            enemies.splice(eIndex, 1);
                        }
                    }
                });
            });

            // Bullets with walls
             bullets.forEach(bullet => {
                if (player.bulletEffects.includes('ricochet') && !bullet.bounced) {
                    if (bullet.x <= ROOM_PADDING || bullet.x >= canvas.width - ROOM_PADDING - bullet.size) {
                        bullet.angle = Math.PI - bullet.angle;
                        bullet.bounced = true;
                    }
                    if (bullet.y <= ROOM_PADDING || bullet.y >= canvas.height - ROOM_PADDING - bullet.size) {
                        bullet.angle = -bullet.angle;
                        bullet.bounced = true;
                    }
                }
             });


            // Player with enemies or enemy bullets
            let tookDamage = false;
            let damageAmount = 0;
            if (!player.invincible) {
                // Direct collision with enemies
                enemies.forEach(enemy => {
                    if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                        player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                        damageAmount = enemy.damage;
                        tookDamage = true;
                    }
                });

                // Collision with enemy bullets
                enemyBullets.forEach((bullet, bIndex) => {
                    if (player.x < bullet.x + bullet.size && player.x + player.width > bullet.x &&
                        player.y < bullet.y + bullet.size && player.y + player.height > bullet.y) {
                        damageAmount = bullet.damage;
                        tookDamage = true;
                        enemyBullets.splice(bIndex, 1);
                    }
                });

                if (tookDamage) {
                    player.health -= damageAmount;
                    player.invincible = true;
                    player.invincibilityEndTime = Date.now() + 5000; // 5 seconds of invincibility
                    updateHUD();
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            }
        }
        
        function chainLightning(target, chainsLeft) {
            if (chainsLeft <= 0) return;

            const nextTarget = findClosestEnemy(target.x, target.y, target);
            if (nextTarget) {
                // You can draw a line here for visual effect if you want
                nextTarget.health -= player.damage * 0.75; // Chain lightning does less damage
                if (nextTarget.health <= 0) {
                    enemies.splice(enemies.indexOf(nextTarget), 1);
                }
                chainLightning(nextTarget, chainsLeft - 1);
            }
        }
        
        // --- Drawing Functions ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawRoom();
            drawPlayer();
            enemies.forEach(drawEnemy);
            bullets.forEach(drawBullet);
            enemyBullets.forEach(drawEnemyBullet);
            explosions.forEach(drawExplosion);
        }

        function drawPlayer() {
            // Flash if invincible by skipping draw calls periodically
            if (player.invincible && Math.floor(Date.now() / 100) % 2 === 0) {
                return;
            }

            // Duck body
            ctx.fillStyle = '#FFD700'; // Yellow
            ctx.fillRect(player.x, player.y, player.width, player.height);
            // Duck beak
            ctx.fillStyle = '#FFA500'; // Orange
            // Determine beak position based on last movement or shot direction
            let lastDirX = keys['d'] ? 1 : (keys['a'] ? -1 : 0);
            let lastDirY = keys['s'] ? 1 : (keys['w'] ? -1 : 0);
            if (keys['arrowright']) lastDirX = 1;
            if (keys['arrowleft']) lastDirX = -1;
            if (keys['arrowdown']) lastDirY = 1;
            if (keys['arrowup']) lastDirY = -1;
            
            if(lastDirX === 0 && lastDirY === 0) lastDirX = 1; // Default facing right

            if (lastDirX !== 0) {
                ctx.fillRect(player.x + (lastDirX > 0 ? player.width : -10), player.y + player.height / 4, 10, player.height / 2);
            } else if (lastDirY !== 0) {
                 ctx.fillRect(player.x + player.width / 4, player.y + (lastDirY > 0 ? player.height : -10), player.width / 2, 10);
            }
        }

        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.frozenUntil ? '#ADD8E6' : enemy.color;
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            
            // Health bar
            if(enemy.health < enemy.maxHealth) {
                ctx.fillStyle = '#dc2626'; // red-600
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                ctx.fillStyle = '#4ade80'; // green-400
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / enemy.maxHealth), 5);
            }
        }

        function drawBullet(bullet) {
            ctx.fillStyle = '#00BFFF'; // DeepSkyBlue
            ctx.beginPath();
            ctx.arc(bullet.x + bullet.size / 2, bullet.y + bullet.size / 2, bullet.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawEnemyBullet(bullet) {
            ctx.fillStyle = '#f56565'; // red-500
            ctx.beginPath();
            ctx.arc(bullet.x + bullet.size / 2, bullet.y + bullet.size / 2, bullet.size / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawRoom() {
            // Walls
            ctx.strokeStyle = '#4a5568'; // gray-700
            ctx.lineWidth = DOOR_THICKNESS;
            ctx.strokeRect(ROOM_PADDING, ROOM_PADDING, canvas.width - ROOM_PADDING * 2, canvas.height - ROOM_PADDING * 2);

            // Doors
            doors.forEach(d => {
                ctx.fillStyle = d.open ? '#2d3748' : '#718096';
                if (d.open && enemies.length === 0) {
                     ctx.fillStyle = '#2d3748';
                     ctx.shadowColor = 'cyan';
                     ctx.shadowBlur = 15;
                }
                
                ctx.fillRect(d.x, d.y, d.width, d.height);
                ctx.shadowBlur = 0; // Reset shadow
            });
        }
        
        function drawExplosion(exp) {
            const progress = exp.lifetime / 0.3; // 0.3 is initial lifetime
            ctx.fillStyle = `rgba(255, 165, 0, ${progress * 0.8})`; // Orange, fades out
            ctx.beginPath();
            const currentRadius = exp.maxRadius * (1 - progress); // Expands from 0 to maxRadius
            ctx.arc(exp.x, exp.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function updateHUD() {
            hud.health.textContent = `${Math.ceil(player.health)} / ${player.maxHealth}`;
            hud.floor.textContent = floor;
            hud.inventory.textContent = player.inventory.join(', ');
        }
        
        // --- Game State Management ---
        function startGame() {
            startScreen.classList.add('hidden');
            gameState = 'playing';
            init();
            requestAnimationFrame(gameLoop);
        }
        
        function levelClear() {
            gameState = 'item_selection';
            lastTime = 0; // Reset delta time calculation
            showItemSelection();
        }

        function gameOver() {
            gameState = 'game_over';
            gameOverScreen.classList.remove('hidden');
        }

        function winGame() {
            gameState = 'post_boss';
            postBossScreen.classList.remove('hidden');
        }

        function showItemSelection() {
            const itemChoicesContainer = document.getElementById('item-choices');
            itemChoicesContainer.innerHTML = '';
            
            let itemPool = endlessMode ? [...ITEMS, ...ENDLESS_ITEMS] : ITEMS;
            const availableItems = itemPool.filter(item => !player.inventory.includes(item.name));
            const choices = [];
            for (let i = 0; i < 3; i++) {
                if (availableItems.length === 0) break;
                const randomIndex = Math.floor(Math.random() * availableItems.length);
                choices.push(availableItems[randomIndex]);
                availableItems.splice(randomIndex, 1);
            }

            choices.forEach(item => {
                const card = document.createElement('div');
                card.className = 'item-card';
                card.innerHTML = `<h3 class="text-lg font-bold mb-2">${item.name}</h3><p class="text-sm">${item.description}</p>`;
                card.onclick = () => {
                    itemSelectionScreen.classList.add('hidden');
                    selectItem(item);
                };
                itemChoicesContainer.appendChild(card);
            });

            itemSelectionScreen.classList.remove('hidden');
        }

        function selectItem(item) {
            item.effect(player);
            if (item.type !== 'stat' && !player.inventory.includes(item.name)) {
                 player.inventory.push(item.name);
            }
            nextLevel();
            gameLoop(performance.now()); // Restart the game loop
        }


        // --- Helper Functions ---
        function createEnemy(x, y) {
            const health = 20 + floor * 10 * (endlessMode ? floor / 5 : 1);
            const damage = 5 + floor * 2 * (endlessMode ? floor / 10 : 1);
            return {
                x, y,
                width: ENEMY_SIZE,
                height: ENEMY_SIZE,
                speed: 50 + Math.random() * 50 + floor * 5,
                health: health,
                maxHealth: health,
                damage: damage,
                color: '#f56565', // red-500
                type: 'melee'
            };
        }
        
        function createRangedEnemy(x, y) {
            const enemy = createEnemy(x,y);
            enemy.color = '#ed8936'; // orange-500
            enemy.type = 'ranged';
            enemy.speed *= 0.7; // Ranged enemies are a bit slower
            enemy.fireRate = 3000 - (floor * 50);
            enemy.lastShotTime = Date.now() + Math.random() * 2000; // Stagger initial shots
            return enemy;
        }
        
        function createBoss() {
            const health = 200 + floor * 40 * (endlessMode ? floor / 5 : 1);
            const damage = 20 + floor * 3 * (endlessMode ? floor / 10 : 1);
            return {
                x: canvas.width / 2 - 50, y: ROOM_PADDING + 20,
                width: 100,
                height: 100,
                speed: 40 + floor * 4,
                health: health,
                maxHealth: health,
                damage: damage,
                color: floor === 10 ? '#9f7aea' : '#dd6b20', // purple-600 for final, orange-600 otherwise
                isBoss: true
            };
        }

        function createBullet(x, y, angle) {
            const bullet = {
                x: x - BULLET_SIZE / 2,
                y: y - BULLET_SIZE / 2,
                size: BULLET_SIZE,
                initialSize: BULLET_SIZE,
                speed: 500,
                angle: angle,
                lifetime: 0
            };
            bullets.push(bullet);
        }

        function createExplosion(x, y, radius, damage) {
            // Add to explosions array for drawing
            explosions.push({x, y, maxRadius: radius, lifetime: 0.3});

            // Damage enemies in radius
            enemies.forEach(enemy => {
                const dist = Math.hypot((enemy.x + enemy.width / 2) - x, (enemy.y + enemy.height / 2) - y);
                if (dist < radius + enemy.width / 2) { // Add enemy width for better collision
                    enemy.health -= damage;
                }
            });
        }

        function createEnemyBullet(x, y, angle, damage) {
             return {
                x: x,
                y: y,
                size: 12,
                speed: 250,
                angle: angle,
                damage: damage
            };
        }

        function findClosestEnemy(x, y, exclude = null) {
            let closest = null;
            let closestDist = Infinity;
            enemies.forEach(e => {
                if (e === exclude) return;
                const dist = Math.hypot(e.x - x, e.y - y);
                if (dist < closestDist) {
                    closest = e;
                    closestDist = dist;
                }
            });
            return closest;
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            startGame();
        });
        playAgainButton.addEventListener('click', () => {
            winScreen.classList.add('hidden');
            startGame();
        });
        finishGameButton.addEventListener('click', () => {
            postBossScreen.classList.add('hidden');
            winScreen.classList.remove('hidden');
        });
        continueGameButton.addEventListener('click', () => {
            postBossScreen.classList.add('hidden');
            endlessMode = true;
            nextLevel();
            gameLoop(performance.now());
        });
    </script>
</body>
</html>
