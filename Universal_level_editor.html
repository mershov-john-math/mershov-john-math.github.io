import React, { useState, useEffect, useMemo, useRef } from 'react';
import { Search, Save, Copy, RefreshCw, Layers, Edit3, MousePointer2, Terminal } from 'lucide-react';

// A set of predefined colors for tile values 0-9
const TILE_COLORS = {
  '0': 'bg-gray-900 border-gray-800 text-gray-600', // Void
  '1': 'bg-slate-500 border-slate-400 text-white',   // Wall
  '2': 'bg-green-600 border-green-500 text-white',   // Player
  '3': 'bg-red-600 border-red-500 text-white',       // Enemy
  '4': 'bg-blue-600 border-blue-500 text-white',     // Water
  '5': 'bg-yellow-600 border-yellow-500 text-white', // Coin
  '6': 'bg-purple-600 border-purple-500 text-white', // Special
  '7': 'bg-pink-600 border-pink-500 text-white',     // Special
  '8': 'bg-orange-600 border-orange-500 text-white', // Special
  '9': 'bg-cyan-600 border-cyan-500 text-white',     // Special
};

const DEFAULT_COLOR = 'bg-gray-700 border-gray-600 text-gray-400';

const DEMO_CODE = `// Game Configuration
const playerSpeed = 5.5;

// Level 1: String Format
// "1" = Wall, "0" = Empty
const levelOneData = [
  "111111111111",
  "100000200001",
  "100111111001",
  "100000300001",
  "111111111111"
];

// Level 2: String Format
const levelTwoData = [
  "11111111",
  "10000001",
  "10100101",
  "10000001",
  "11110011",
  "10000001",
  "11111111"
];

// Level 3: Array of Arrays Format
// Now supported!
const levelThreeData = [
  [1, 1, 1, 1, 1],
  [1, 0, 5, 0, 1],
  [1, 2, 0, 3, 1],
  [1, 0, 5, 0, 1],
  [1, 1, 1, 1, 1]
];

function initGame() {
  console.log("Loading levels...");
}`;

export default function UniversalLevelEditor() {
  const [code, setCode] = useState(DEMO_CODE);
  const [foundLevels, setFoundLevels] = useState([]);
  const [selectedLevelIndex, setSelectedLevelIndex] = useState(null);
  const [brush, setBrush] = useState('1');
  const [isDragging, setIsDragging] = useState(false);
  const [viewMode, setViewMode] = useState('split'); // 'split', 'code', 'editor'

  // --- The Core Logic: Scanning the Text ---
  useEffect(() => {
    scanForLevels(code);
  }, [code]);

  const scanForLevels = (inputText) => {
    const levels = [];
    let match;
    let idCounter = 0;
    
    // --- Strategy 1: Find Arrays of Strings ["111", "001"] ---
    const stringArrayRegex = /\[\s*((?:["']\d+["']\s*,?\s*)+)\]/g;
    
    while ((match = stringArrayRegex.exec(inputText)) !== null) {
      const fullMatch = match[0];
      const innerContent = match[1];
      
      const rowRegex = /(['"])(\d+)\1/g;
      let rowMatch;
      const rows = [];
      let quoteType = '"';
      
      while ((rowMatch = rowRegex.exec(innerContent)) !== null) {
        quoteType = rowMatch[1];
        rows.push(rowMatch[2]);
      }

      if (isValidGrid(rows)) {
        levels.push({
          id: idCounter++,
          type: 'string-rows', // Track the format
          rows: rows,
          width: rows[0].length,
          height: rows.length,
          startIndex: match.index,
          endIndex: match.index + fullMatch.length,
          quoteType: quoteType,
        });
      }
    }

    // --- Strategy 2: Find Arrays of Arrays [[1,0,1], [0,1,0]] ---
    // Look for outer brackets containing inner brackets with numbers
    const numberArrayRegex = /\[\s*((?:\[\s*[\d\s,]+\s*\]\s*,?\s*)+)\]/g;

    while ((match = numberArrayRegex.exec(inputText)) !== null) {
      const fullMatch = match[0];
      const innerContent = match[1];
      
      // Parse inner arrays: [0, 1, 0]
      const rowContainerRegex = /\[([\d\s,]+)\]/g;
      let rowMatch;
      const rows = [];
      
      while ((rowMatch = rowContainerRegex.exec(innerContent)) !== null) {
        // rowMatch[1] is "0, 1, 0"
        // Normalize to string "010" for internal editor consistency
        const cleanRow = rowMatch[1].split(',').map(s => s.trim()).join('');
        rows.push(cleanRow);
      }

      if (isValidGrid(rows)) {
        levels.push({
          id: idCounter++,
          type: 'number-arrays', // Track the format
          rows: rows,
          width: rows[0].length,
          height: rows.length,
          startIndex: match.index,
          endIndex: match.index + fullMatch.length,
        });
      }
    }

    // Sort levels by position in file so they appear in logical order
    levels.sort((a, b) => a.startIndex - b.startIndex);

    setFoundLevels(levels);
    
    // Auto-select logic
    if (selectedLevelIndex === null && levels.length > 0) {
      setSelectedLevelIndex(0);
    }
  };

  // Helper to validate if rows form a rectangle
  const isValidGrid = (rows) => {
    if (rows.length < 2) return false;
    const width = rows[0].length;
    // Ensure all rows are same length and width is reasonable
    return width > 1 && rows.every(r => r.length === width);
  };

  // --- The Patcher: Injecting Edits back into Code ---
  const updateCode = (levelIndex, newRows) => {
    if (!foundLevels[levelIndex]) return;

    const level = foundLevels[levelIndex];
    let newArrayString = '';

    if (level.type === 'string-rows') {
        // Reconstruct ["111", "001"]
        const quote = level.quoteType;
        newArrayString = `[\n  ${newRows.map(row => `${quote}${row}${quote}`).join(',\n  ')}\n]`;
    } else if (level.type === 'number-arrays') {
        // Reconstruct [[1,1,1], [0,0,1]]
        // We take the string "111" and split it back to joined numbers "1, 1, 1"
        newArrayString = `[\n  ${newRows.map(row => `[${row.split('').join(', ')}]`).join(',\n  ')}\n]`;
    }

    const before = code.substring(0, level.startIndex);
    const after = code.substring(level.endIndex);
    
    const newCode = before + newArrayString + after;
    setCode(newCode);
  };

  const handleCellEdit = (y, x, val) => {
    if (selectedLevelIndex === null) return;
    
    // Safely get index within bounds of currently found levels
    // (Scanning happens on every render/edit so indices might shift if levels are added/removed, but usually stable)
    if (!foundLevels[selectedLevelIndex]) return;

    const currentLevel = foundLevels[selectedLevelIndex];
    const newRows = [...currentLevel.rows];
    
    // String replacement at index (we use string representation internally for both formats)
    const targetRow = newRows[y];
    const newRow = targetRow.substring(0, x) + val + targetRow.substring(x + 1);
    newRows[y] = newRow;

    updateCode(selectedLevelIndex, newRows);
  };

  const handleMouseEnter = (y, x) => {
    if (isDragging) {
      handleCellEdit(y, x, brush);
    }
  };

  const handleMouseDown = (y, x) => {
    setIsDragging(true);
    handleCellEdit(y, x, brush);
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const activeLevel = foundLevels[selectedLevelIndex];

  return (
    <div className="flex flex-col h-screen bg-gray-950 text-gray-200 font-sans overflow-hidden" onMouseUp={handleMouseUp}>
      {/* Header */}
      <header className="h-14 bg-gray-900 border-b border-gray-800 flex items-center justify-between px-4 shrink-0">
        <div className="flex items-center gap-2">
          <div className="p-1.5 bg-blue-600 rounded text-white">
            <Layers size={20} />
          </div>
          <h1 className="font-bold text-lg tracking-tight text-white">LevelScan <span className="text-blue-500">Universal</span></h1>
        </div>

        <div className="flex items-center gap-4">
           <div className="flex bg-gray-800 rounded-lg p-1 text-xs font-medium">
             <button 
               onClick={() => setViewMode('split')}
               className={`px-3 py-1 rounded ${viewMode === 'split' ? 'bg-gray-700 text-white shadow' : 'text-gray-500 hover:text-gray-300'}`}>
               Split
             </button>
             <button 
               onClick={() => setViewMode('code')}
               className={`px-3 py-1 rounded ${viewMode === 'code' ? 'bg-gray-700 text-white shadow' : 'text-gray-500 hover:text-gray-300'}`}>
               Code Only
             </button>
             <button 
               onClick={() => setViewMode('editor')}
               className={`px-3 py-1 rounded ${viewMode === 'editor' ? 'bg-gray-700 text-white shadow' : 'text-gray-500 hover:text-gray-300'}`}>
               Editor Only
             </button>
           </div>
        </div>
      </header>

      {/* Main Content */}
      <div className="flex-1 flex overflow-hidden">
        
        {/* Left Panel: Code Input */}
        <div className={`flex-col border-r border-gray-800 bg-gray-950 ${viewMode === 'editor' ? 'hidden' : 'flex'} ${viewMode === 'split' ? 'w-1/3' : 'w-full'}`}>
          <div className="h-10 bg-gray-900 border-b border-gray-800 flex items-center px-4 justify-between text-xs text-gray-400 uppercase tracking-wider font-semibold">
            <span className="flex items-center gap-2"><Terminal size={14} /> Source Code</span>
            <span className="text-blue-400">{foundLevels.length} Levels Detected</span>
          </div>
          <textarea 
            value={code}
            onChange={(e) => setCode(e.target.value)}
            className="flex-1 w-full bg-gray-950 text-gray-300 font-mono text-sm p-4 focus:outline-none resize-none leading-relaxed"
            spellCheck="false"
          />
        </div>

        {/* Right Panel: Level Editor */}
        <div className={`flex-col bg-gray-900/50 ${viewMode === 'code' ? 'hidden' : 'flex'} ${viewMode === 'split' ? 'w-2/3' : 'w-full'}`}>
          
          {/* Editor Toolbar */}
          <div className="h-14 border-b border-gray-800 bg-gray-900 flex items-center justify-between px-4 shrink-0">
            <div className="flex items-center gap-4 overflow-x-auto">
              <div className="flex items-center gap-2 mr-4 border-r border-gray-700 pr-4">
                 <span className="text-xs text-gray-500 uppercase font-bold">Level:</span>
                 <select 
                    className="bg-gray-800 border border-gray-700 text-sm rounded px-2 py-1 focus:outline-none focus:border-blue-500"
                    value={selectedLevelIndex !== null ? selectedLevelIndex : ''}
                    onChange={(e) => setSelectedLevelIndex(Number(e.target.value))}
                    disabled={foundLevels.length === 0}
                 >
                   {foundLevels.map((lvl, idx) => (
                     <option key={idx} value={idx}>
                       #{idx + 1} ({lvl.width}x{lvl.height}) [{lvl.type === 'string-rows' ? 'String' : 'Array'}]
                     </option>
                   ))}
                   {foundLevels.length === 0 && <option>No levels found</option>}
                 </select>
              </div>

              <div className="flex items-center gap-1">
                <span className="text-xs text-gray-500 uppercase font-bold mr-2">Brush:</span>
                {['0','1','2','3','4','5'].map(val => (
                   <button
                    key={val}
                    onClick={() => setBrush(val)}
                    className={`w-8 h-8 rounded border flex items-center justify-center text-xs font-bold transition-all
                      ${brush === val ? 'ring-2 ring-white scale-110 z-10' : 'opacity-70 hover:opacity-100 hover:scale-105'}
                      ${TILE_COLORS[val] || DEFAULT_COLOR}
                    `}
                   >
                     {val}
                   </button>
                ))}
                <div className="w-px h-6 bg-gray-700 mx-2"></div>
                <div className="text-xs text-gray-500 flex items-center gap-1">
                   <MousePointer2 size={12} />
                   <span>Left Click + Drag to paint</span>
                </div>
              </div>
            </div>
          </div>

          {/* Grid Canvas */}
          <div className="flex-1 bg-[url('https://www.transparenttextures.com/patterns/dark-matter.png')] bg-gray-950 overflow-auto p-8 flex items-center justify-center">
             
             {activeLevel ? (
               <div className="relative shadow-2xl rounded-lg overflow-hidden border-4 border-gray-800 bg-black">
                  {activeLevel.rows.map((row, y) => (
                    <div key={y} className="flex">
                      {row.split('').map((char, x) => (
                        <div 
                          key={`${y}-${x}`}
                          onMouseDown={() => handleMouseDown(y, x)}
                          onMouseEnter={() => handleMouseEnter(y, x)}
                          className={`
                            w-10 h-10 border-r border-b border-opacity-20 flex items-center justify-center 
                            cursor-pointer select-none hover:brightness-125 transition-colors duration-75
                            ${TILE_COLORS[char] || DEFAULT_COLOR}
                          `}
                        >
                          <span className="opacity-50 text-xs font-mono">{char}</span>
                        </div>
                      ))}
                    </div>
                  ))}
               </div>
             ) : (
               <div className="text-center text-gray-500 max-w-md">
                 <Search size={48} className="mx-auto mb-4 opacity-20" />
                 <h3 className="text-lg font-medium text-gray-400">No Level Data Detected</h3>
                 <p className="mt-2 text-sm text-gray-600">
                   Paste your game code on the left. The scanner looks for lists of strings or lists of lists of numbers.
                 </p>
                 <code className="block bg-gray-900 p-3 rounded mt-4 text-left text-xs text-green-400 font-mono">
                   const level = [<br/>
                   &nbsp;&nbsp;[1, 1, 1],<br/>
                   &nbsp;&nbsp;[1, 0, 1]<br/>
                   ];
                 </code>
               </div>
             )}
          </div>
          
          {/* Footer Stats */}
          <div className="h-8 bg-gray-900 border-t border-gray-800 flex items-center justify-between px-4 text-xs text-gray-500">
             {activeLevel ? (
               <span>
                   Grid Size: {activeLevel.width} x {activeLevel.height} â€¢ 
                   Type: {activeLevel.type === 'string-rows' ? `Strings (${activeLevel.quoteType})` : 'Number Arrays'}
               </span>
             ) : (
               <span>Waiting for input...</span>
             )}
             <span>Auto-Update Enabled</span>
          </div>

        </div>
      </div>
    </div>
  );
}
