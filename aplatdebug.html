<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Playlist Creator</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --dark-bg: #1a1a1a;
            --medium-bg: #2a2a2a;
            --dark-border: #555;
            --text-color: #f0f0f0;
            --game-bg-color: #ffffff;
            --platform-color: #000000;
            --player-color: #0096FF;
            --goal-color: #FFD700;
            --grid-color: #cccccc;
            --spike-color: #FF0000; /* New color for spikes */
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; padding: 0; background-color: var(--dark-bg); color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden;
        }
        canvas {
            border: 2px solid var(--dark-border); cursor: crosshair;
        }
        .screen {
            display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%;
        }
        .screen.active { display: flex; }

        h1, h2 { color: var(--primary-color); text-shadow: 2px 2px #000; }
        button, input {
            padding: 12px 20px; margin: 8px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer;
            background-color: var(--primary-color); color: white; transition: background-color 0.3s;
        }
        button:hover { background-color: #45a049; }
        input[type="text"] {
            width: 90%; background-color: #333; border: 2px solid var(--dark-border);
        }

        #editor-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 20px;
        }
        #editor-screen.active { display: flex; }

        #editor-container { 
            display: flex; gap: 20px; align-items: flex-start; margin-top: 20px;
        }
        #editor-main-area {
            display: flex; flex-direction: column; align-items: center;
        }
        #playlist-controls { 
            background-color: var(--medium-bg); padding: 15px; border-radius: 8px; width: 250px; text-align: center;
        }
        #playlist-levels-list { 
            list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; text-align: left;
        }
        #playlist-levels-list li {
            padding: 10px; margin-bottom: 5px; background: #333; border-radius: 4px; cursor: pointer;
            border-left: 4px solid transparent;
        }
        #playlist-levels-list li.selected { border-left-color: var(--primary-color); background: #444; }

        #editor-tools-panel {
            background-color: var(--medium-bg);
            padding: 15px;
            border-radius: 8px;
            width: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #editor-tools-panel span {
            margin-bottom: 10px;
            font-weight: bold;
        }
        .tool { 
            padding: 10px; margin: 5px; border: 2px solid var(--dark-border); border-radius: 5px; cursor: pointer; 
            width: 80%;
        }
        .tool.selected { background-color: var(--primary-color); border-color: #fff; }
        
        #editor-bottom-bar {
            display: flex; justify-content: center; margin-top: 20px;
        }
        #key-output { 
            margin-top: 15px; width: 80%; max-width: 800px; padding: 10px; background: #222; border: 1px solid #444; word-wrap: break-word; min-height: 20px; font-family: 'Courier New', monospace; 
        }

        #game-screen {
            display: none; position: relative; width: 100vw; height: 100vh;
            background-color: var(--dark-bg); overflow: hidden;
        }
        #game-screen.active {
            display: flex; flex-direction: column; justify-content: space-between; align-items: center;
        }
        #game-canvas {
            background-color: var(--game-bg-color); flex-grow: 1;
            width: 100%; height: 100%; border: none; display: block;
        }
        #game-ui-bar {
            background-color: var(--medium-bg);
            width: 100%;
            padding: 10px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            position: relative;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
            min-height: 60px;
        }
        #game-ui-bar h2 {
            margin: 0; font-size: 1.2em;
        }
        #game-ui-bar button {
            margin: 0 15px;
        }

        #level-selector-grid { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; }
    </style>
</head>
<body>

    <div id="main-menu" class="screen active">
        <h1>Platformer Playlist Creator</h1>
        <button onclick="startNewPlaylist()">Create New Playlist</button>
        <input type="text" id="key-input" placeholder="Paste Level or Playlist Key...">
        <button onclick="loadKeyFromInput()">Play</button>
    </div>

    <div id="editor-screen" class="screen">
        <h1>Level Editor</h1>
        <div id="editor-container">
            <div id="playlist-controls">
                <h2>Playlist Editor</h2>
                <input type="text" id="playlist-name" placeholder="Playlist Name" onchange="updatePlaylistName()">
                <ul id="playlist-levels-list"></ul>
                <button onclick="addNewLevel()">Add New Level</button>
                <button onclick="deleteSelectedLevel()">Delete Selected</button>
                
                <hr style="border-color: var(--dark-border); margin: 20px 0;">
                <input type="text" id="playlist-key-importer" placeholder="Paste Playlist Key...">
                <button onclick="importPlaylistToEditor()">Load Key to Editor</button>
            </div>
            <div id="editor-main-area">
                <canvas id="editor-canvas"></canvas>
                <div id="editor-bottom-bar">
                    <button onclick="exportPlaylistKey()">Export Playlist Key</button>
                    <button onclick="showScreen('main-menu')">Back to Menu</button>
                </div>
                <div id="key-output"></div>
            </div>
            <div id="editor-tools-panel"> 
                <span>Tools:</span>
                <div class="tool selected" id="tool-wall" onclick="selectTool('wall')">üß± Wall</div>
                <div class="tool" id="tool-player" onclick="selectTool('player')">üë§ Player</div>
                <div class="tool" id="tool-goal" onclick="selectTool('goal')">‚≠ê Goal</div>
                <div class="tool" id="tool-spike" onclick="selectTool('spike')">üî∫ Spikes</div>
                <div class="tool" id="tool-erase" onclick="selectTool('erase')">‚ùå Erase</div>
            </div>
        </div>
    </div>

    <div id="level-selector-screen" class="screen">
        <h1 id="playlist-title"></h1>
        <div id="level-selector-grid"></div>
        <button onclick="showScreen('main-menu')">Back to Menu</button>
    </div>

    <div id="game-screen" class="screen">
        <canvas id="game-canvas"></canvas>
        <div id="game-ui-bar">
            <h2 id="game-level-title"></h2>
            <p style="margin:0; font-size: 0.9em; color: #bbb;">Use Arrow Keys/WASD to move. Hold jump for height.</p>
            <button onclick="showScreen('level-selector-screen')">Back to Level Select</button>
        </div>
    </div>

    <script>
    // --- CONFIG ---
    const SPEED_MODIFIER = 0.25; // üëà Set to 0.25 for 25% speed
    const GRID_SIZE = 20;
    const GRAVITY = 0.25 * SPEED_MODIFIER;
    const JUMP_FORCE = -6 * SPEED_MODIFIER;
    const MOVE_SPEED = 2.5 * SPEED_MODIFIER;

    const EDITOR_CANVAS_WIDTH = 800;
    const EDITOR_CANVAS_HEIGHT = 480;

    // --- DOM ELEMENTS ---
    const editorCanvas = document.getElementById('editor-canvas'), editorCtx = editorCanvas.getContext('2d');
    const gameCanvas = document.getElementById('game-canvas'), gameCtx = gameCanvas.getContext('2d');
    const keyOutput = document.getElementById('key-output');

    editorCanvas.width = EDITOR_CANVAS_WIDTH;
    editorCanvas.height = EDITOR_CANVAS_HEIGHT;

    // --- STATE ---
    let currentScreen = 'main-menu', selectedTool = 'wall', isPainting = false;
    const keys = {};
    
    let editorPlaylist = { name: "Untitled Playlist", levels: [] };
    let currentEditingLevelIndex = -1;

    let player = { x: 0, y: 0, width: GRID_SIZE * 0.8, height: GRID_SIZE * 0.8, vx: 0, vy: 0, onGround: false };
    let gameObjects = [], gameGoalPos = {}, gamePlayerStart = {}, gameSpikes = [];
    let currentPlaylist = { name: "", levels: [] };
    let currentLevelIndex = -1;

    // --- SCREEN NAVIGATION ---
    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
        currentScreen = screenId;
        if (screenId === 'game-screen') {
            resizeGameCanvas();
        } else if (screenId === 'editor-screen') {
            drawEditor();
        }
    }

    // --- EDITOR LOGIC ---
    function startNewPlaylist() {
        editorPlaylist = { name: "Untitled Playlist", levels: [{ p: [-1,-1], g: [-1,-1], w: [], s: [] }] };
        document.getElementById('playlist-name').value = editorPlaylist.name;
        selectLevelForEditing(0);
        showScreen('editor-screen');
    }
    
    function updatePlaylistName() {
        editorPlaylist.name = document.getElementById('playlist-name').value || "Untitled Playlist";
    }

    function selectLevelForEditing(index) {
        if (index < 0 || index >= editorPlaylist.levels.length) {
            currentEditingLevelIndex = -1;
            drawEditor();
            return;
        }
        currentEditingLevelIndex = index;
        drawEditor();
        updateLevelListUI();
    }

    function addNewLevel() {
        editorPlaylist.levels.push({ p: [-1, -1], g: [-1, -1], w: [], s: [] });
        selectLevelForEditing(editorPlaylist.levels.length - 1);
    }
    
    function deleteSelectedLevel() {
        if (currentEditingLevelIndex < 0) return;
        editorPlaylist.levels.splice(currentEditingLevelIndex, 1);
        if (editorPlaylist.levels.length === 0) {
            currentEditingLevelIndex = -1;
            drawEditor();
        } else {
            selectLevelForEditing(Math.max(0, currentEditingLevelIndex - 1));
        }
        updateLevelListUI();
    }
    
    function updateLevelListUI() {
        const list = document.getElementById('playlist-levels-list');
        list.innerHTML = '';
        editorPlaylist.levels.forEach((level, index) => {
            const li = document.createElement('li');
            li.textContent = `Level ${index + 1}`;
            if (index === currentEditingLevelIndex) li.classList.add('selected');
            li.onclick = () => selectLevelForEditing(index);
            list.appendChild(li);
        });
    }

    function selectTool(tool) {
        document.querySelectorAll('#editor-tools-panel .tool').forEach(t => t.classList.remove('selected'));
        document.getElementById(`tool-${tool}`).classList.add('selected');
        selectedTool = tool;
    }

    function drawEditor() {
        editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
        editorCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--game-bg-color');
        editorCtx.fillRect(0, 0, editorCanvas.width, editorCanvas.height);

        editorCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color');
        editorCtx.lineWidth = 0.5;
        for (let x = 0; x < editorCanvas.width; x += GRID_SIZE) { editorCtx.beginPath(); editorCtx.moveTo(x, 0); editorCtx.lineTo(x, editorCanvas.height); editorCtx.stroke(); }
        for (let y = 0; y < editorCanvas.height; y += GRID_SIZE) { editorCtx.beginPath(); editorCtx.moveTo(0, y); editorCtx.lineTo(editorCanvas.width, y); editorCtx.stroke(); }
        editorCtx.lineWidth = 1;

        if (currentEditingLevelIndex < 0) return;
        const level = editorPlaylist.levels[currentEditingLevelIndex];
        
        editorCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--platform-color');
        level.w.forEach(pos => editorCtx.fillRect(pos[0] * GRID_SIZE, pos[1] * GRID_SIZE, GRID_SIZE, GRID_SIZE));
        
        editorCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--spike-color');
        level.s.forEach(pos => drawSpike(editorCtx, pos[0] * GRID_SIZE, pos[1] * GRID_SIZE, GRID_SIZE));

        if (level.p[0] !== -1) {
            editorCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-color');
            editorCtx.fillRect(level.p[0] * GRID_SIZE, level.p[1] * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        }
        if (level.g[0] !== -1) {
            editorCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--goal-color');
            drawStar(editorCtx, level.g[0] * GRID_SIZE + GRID_SIZE / 2, level.g[1] * GRID_SIZE + GRID_SIZE / 2, GRID_SIZE / 2 * 0.9, 5);
        }
    }

    function handleEditorAction(event) {
        if (currentEditingLevelIndex < 0) return;
        const rect = editorCanvas.getBoundingClientRect();
        const gridX = Math.floor((event.clientX - rect.left) / GRID_SIZE);
        const gridY = Math.floor((event.clientY - rect.top) / GRID_SIZE);
        if (gridX < 0 || gridX >= editorCanvas.width / GRID_SIZE || gridY < 0 || gridY >= editorCanvas.height / GRID_SIZE) return;

        const level = editorPlaylist.levels[currentEditingLevelIndex];

        const clearSpot = () => {
            level.w = level.w.filter(pos => pos[0] !== gridX || pos[1] !== gridY);
            level.s = level.s.filter(pos => pos[0] !== gridX || pos[1] !== gridY);
            if(level.p[0] === gridX && level.p[1] === gridY) level.p = [-1,-1];
            if(level.g[0] === gridX && level.g[1] === gridY) level.g = [-1,-1];
        }

        if (selectedTool === 'erase') {
            clearSpot();
        } else if (selectedTool === 'wall') {
            clearSpot();
            level.w.push([gridX, gridY]);
        } else if (selectedTool === 'player') {
            clearSpot();
            level.p = [gridX, gridY];
        } else if (selectedTool === 'goal') {
            clearSpot();
            level.g = [gridX, gridY];
        } else if (selectedTool === 'spike') {
            clearSpot();
            level.s.push([gridX, gridY]);
        }
        drawEditor();
    }
    editorCanvas.addEventListener('mousedown', (e) => { isPainting = true; handleEditorAction(e); });
    editorCanvas.addEventListener('mousemove', (e) => { if (isPainting) handleEditorAction(e); });
    window.addEventListener('mouseup', () => isPainting = false);
    editorCanvas.addEventListener('mouseleave', () => isPainting = false);

    // --- KEY IMPORT / EXPORT ---
    function importPlaylistToEditor() {
        const keyInput = document.getElementById('playlist-key-importer');
        const key = keyInput.value.trim();
        if (!key) {
            alert("Please paste a key into the 'Code' box first.");
            return;
        }
        try {
            const decoded = JSON.parse(atob(key));
            if (decoded.type !== 'playlist' || !Array.isArray(decoded.data)) {
                throw new Error("Invalid key type. Only Playlist Keys can be loaded here.");
            }
            
            // Backwards compatibility for old keys without spikes
            decoded.data.forEach(level => {
                if (!level.s) level.s = [];
            });

            editorPlaylist = { name: decoded.name, levels: decoded.data };
            
            document.getElementById('playlist-name').value = editorPlaylist.name;
            selectLevelForEditing(0);
            
            keyInput.value = '';
            alert(`Playlist '${editorPlaylist.name}' loaded successfully!`);
        } catch (e) {
            alert("Invalid Playlist Key. Please check the code and try again.");
            console.error(e);
        }
    }

    function exportPlaylistKey() {
        for(let i = 0; i < editorPlaylist.levels.length; i++) {
            const level = editorPlaylist.levels[i];
            if (level.p[0] === -1 || level.g[0] === -1) {
                alert(`Level ${i + 1} is incomplete! It needs a Player Start and a Goal.`);
                return;
            }
        }
        const finalObject = { type: "playlist", name: editorPlaylist.name, data: editorPlaylist.levels };
        keyOutput.textContent = btoa(JSON.stringify(finalObject));
    }

    function loadKeyFromInput() {
        try {
            const key = document.getElementById('key-input').value.trim();
            const decoded = JSON.parse(atob(key));
            
            if (decoded.type === 'playlist') {
                // Backwards compatibility for old keys without spikes
                decoded.data.forEach(level => {
                    if (!level.s) level.s = [];
                });
                currentPlaylist = { name: decoded.name, levels: decoded.data };
                displayLevelSelector();
            } else { // Handle old single-level key
                if (!decoded.s) decoded.s = [];
                currentPlaylist = { name: "Single Level", levels: [decoded] };
                startLevel(0);
            }
        } catch (e) {
            alert("Invalid key!");
            console.error(e);
        }
    }
    
    // --- LEVEL SELECTOR & GAME FLOW ---
    function displayLevelSelector() {
        const grid = document.getElementById('level-selector-grid');
        document.getElementById('playlist-title').textContent = currentPlaylist.name;
        grid.innerHTML = '';
        currentPlaylist.levels.forEach((level, index) => {
            const button = document.createElement('button');
            button.textContent = `Level ${index + 1}`;
            button.onclick = () => startLevel(index);
            grid.appendChild(button);
        });
        showScreen('level-selector-screen');
    }

    function startLevel(index) {
        currentLevelIndex = index;
        const levelData = currentPlaylist.levels[index];
        
        gamePlayerStart = { x: levelData.p[0] * GRID_SIZE, y: levelData.p[1] * GRID_SIZE };
        gameGoalPos = { x: levelData.g[0] * GRID_SIZE, y: levelData.g[1] * GRID_SIZE };
        gameObjects = levelData.w.map(pos => ({ x: pos[0] * GRID_SIZE, y: pos[1] * GRID_SIZE }));
        gameSpikes = (levelData.s || []).map(pos => ({ x: pos[0] * GRID_SIZE, y: pos[1] * GRID_SIZE }));

        document.getElementById('game-level-title').textContent = `${currentPlaylist.name} - Level ${index + 1}`;
        resetGame();
        showScreen('game-screen');
        gameLoop();
    }

    function onLevelComplete() {
        currentLevelIndex++;
        if (currentLevelIndex < currentPlaylist.levels.length) {
            startLevel(currentLevelIndex);
        } else {
            alert(`üéâ Playlist Complete! You beat ${currentPlaylist.name}! üéâ`);
            displayLevelSelector();
        }
    }

    // --- GAME LOGIC ---
    function resetGame() {
        player.x = gamePlayerStart.x + (GRID_SIZE - player.width) / 2;
        player.y = gamePlayerStart.y + (GRID_SIZE - player.height) / 2;
        player.vx = 0; player.vy = 0; player.onGround = false;
    }

    function updateGame() {
        player.vx = 0;
        if (keys['ArrowLeft'] || keys['a']) player.vx = -MOVE_SPEED;
        if (keys['ArrowRight'] || keys['d']) player.vx = MOVE_SPEED;
        if ((keys['ArrowUp'] || keys['w'] || keys[' ']) && player.onGround) { player.vy = JUMP_FORCE; player.onGround = false; }
        player.vy += GRAVITY;

        player.x += player.vx;
        for (const wall of gameObjects) {
            if (player.x < wall.x + GRID_SIZE && player.x + player.width > wall.x && player.y < wall.y + GRID_SIZE && player.y + player.height > wall.y) {
                if (player.vx > 0) player.x = wall.x - player.width;
                if (player.vx < 0) player.x = wall.x + GRID_SIZE;
            }
        }
        player.y += player.vy;
        player.onGround = false;
        for (const wall of gameObjects) {
            if (player.x < wall.x + GRID_SIZE && player.x + player.width > wall.x && player.y < wall.y + GRID_SIZE && player.y + player.height > wall.y) {
                if (player.vy > 0) { player.y = wall.y - player.height; player.onGround = true; player.vy = 0; }
                if (player.vy < 0) { player.y = wall.y + GRID_SIZE; player.vy = 0; }
            }
        }
        // Spike Collision
        for (const spike of gameSpikes) {
            if (player.x < spike.x + GRID_SIZE && player.x + player.width > spike.x && player.y < spike.y + GRID_SIZE && player.y + player.height > spike.y) {
                resetGame();
                return; // Exit update loop immediately
            }
        }

        if (player.x < gameGoalPos.x + GRID_SIZE && player.x + player.width > gameGoalPos.x && player.y < gameGoalPos.y + GRID_SIZE && player.y + player.height > gameGoalPos.y) {
            onLevelComplete();
        }
        if (player.y > gameCanvas.height) resetGame();
    }

    function drawGame() {
        gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--game-bg-color');
        gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--platform-color');
        gameObjects.forEach(obj => gameCtx.fillRect(obj.x, obj.y, GRID_SIZE, GRID_SIZE));
        
        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--spike-color');
        gameSpikes.forEach(spike => drawSpike(gameCtx, spike.x, spike.y, GRID_SIZE));

        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--goal-color');
        drawStar(gameCtx, gameGoalPos.x + GRID_SIZE / 2, gameGoalPos.y + GRID_SIZE / 2, GRID_SIZE / 2 * 0.9, 5);

        gameCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-color');
        gameCtx.fillRect(player.x, player.y, player.width, player.height);
    }
    
    function drawStar(ctx, cx, cy, outerRadius, spikes, innerRadius = outerRadius * 0.4) {
        let rot = Math.PI / 2 * 3; let x = cx; let y = cy;
        let step = Math.PI / spikes;
        ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y); rot += step;
            x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y); rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill();
    }

    function drawSpike(ctx, x, y, size) {
        ctx.beginPath();
        ctx.moveTo(x, y + size);
        ctx.lineTo(x + size / 2, y);
        ctx.lineTo(x + size, y + size);
        ctx.closePath();
        ctx.fill();
    }

    let animationFrameId;
    function gameLoop() {
        if (currentScreen !== 'game-screen') {
            cancelAnimationFrame(animationFrameId);
            return;
        }
        updateGame();
        drawGame();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function resizeGameCanvas() {
        if (currentScreen !== 'game-screen') return;
        const gameScreen = document.getElementById('game-screen');
        const gameUiBar = document.getElementById('game-ui-bar');
        const availableHeight = gameScreen.clientHeight - gameUiBar.offsetHeight;
        const availableWidth = gameScreen.clientWidth;
        const aspectRatio = EDITOR_CANVAS_WIDTH / EDITOR_CANVAS_HEIGHT;
        let newWidth = availableWidth;
        let newHeight = availableWidth / aspectRatio;
        if (newHeight > availableHeight) {
            newHeight = availableHeight;
            newWidth = availableHeight * aspectRatio;
        }
        gameCanvas.width = newWidth;
        gameCanvas.height = newHeight;
        drawGame();
    }
    window.addEventListener('resize', resizeGameCanvas);
    
    window.addEventListener('keydown', (e) => keys[e.key] = true);
    window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
        if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && player.vy < 0) { player.vy *= 0.5; }
    });
    window.addEventListener('blur', () => { for (const key in keys) { keys[key] = false; } });
    
    showScreen('main-menu');
    </script>
</body>
</html>
