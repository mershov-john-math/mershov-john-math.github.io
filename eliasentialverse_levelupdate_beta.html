<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eliasentialverse - Build & Play</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlays */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); border: 2px solid #333;
            z-index: 10;
        }

        #hud {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.5); color: white; padding: 15px;
            border-radius: 10px; pointer-events: auto;
            border: 2px solid #FFD700;
        }
        .stat { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        .sub-stat { font-size: 14px; color: #ddd; }

        #interaction-msg {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); color: #fff; padding: 10px 20px;
            border-radius: 20px; font-size: 16px; opacity: 0; transition: opacity 0.2s;
            pointer-events: none;
        }

        /* Menus */
        #start-screen, #load-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 165, 0, 0.95); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
            pointer-events: auto; text-align: center; color: white;
        }
        #load-modal { background: rgba(0,0,0,0.9); display: none; }

        h1 { font-size: 60px; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        p { font-size: 20px; max-width: 600px; line-height: 1.5; }
        
        .btn-group { display: flex; gap: 20px; margin-top: 30px; }
        .btn {
            background: white; color: orange; border: none; padding: 15px 30px;
            font-size: 20px; font-weight: bold; border-radius: 30px; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); transition: transform 0.1s;
        }
        .btn:hover { transform: scale(1.05); }
        .btn-blue { color: #2196F3; }
        .btn-green { color: #4CAF50; }

        textarea {
            width: 600px; height: 200px; margin: 20px; padding: 10px;
            border-radius: 10px; border: none; font-family: monospace;
        }

        /* Shop & Builder UI */
        #shop-panel, #house-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 600px; height: 500px; background: white; border-radius: 15px;
            display: none; flex-direction: column; pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); overflow: hidden;
            z-index: 50; border: 4px solid orange;
        }
        .panel-header {
            background: orange; color: white; padding: 15px; font-size: 24px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .close-btn { cursor: pointer; font-weight: bold; }
        .panel-content { padding: 20px; overflow-y: auto; flex: 1; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;}
        
        .item-card {
            border: 1px solid #ddd; border-radius: 8px; padding: 10px;
            text-align: center; cursor: pointer; transition: background 0.2s;
            background: #f9f9f9;
        }
        .item-card:hover { background: #ffeebb; }
        .item-name { font-weight: bold; color: #333; font-size: 14px; }
        .item-price { color: green; font-weight: bold; font-size: 12px; }
        .buy-btn {
            background: orange; color: white; border: none; padding: 5px 10px;
            border-radius: 5px; margin-top: 5px; cursor: pointer; width: 100%;
        }
        .buy-btn:disabled { background: #ccc; cursor: not-allowed; }

        #notification {
            position: absolute; bottom: 30px; right: 30px;
            background: #4CAF50; color: white; padding: 15px 25px;
            border-radius: 8px; transform: translateX(200%); transition: transform 0.3s;
        }
        #notification.show { transform: translateX(0); }
        
        #build-controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 10px 20px; border-radius: 20px;
            display: none; font-size: 14px;
        }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="crosshair"></div>
        
        <div id="hud">
            <div class="stat">Coins: <span id="score-display">0</span></div>
            <div class="sub-stat">Mode: <span id="mode-display">Adventure</span></div>
            <div class="sub-stat" id="controls-hint">WASD to Move | Space to Jump | E to Interact</div>
            <div class="sub-stat" id="edit-hint" style="display:none; color: #FFD700; margin-top: 5px;">[I] Customize House</div>
        </div>

        <div id="interaction-msg">Press E to Interact</div>
        <div id="notification">Notification</div>
        
        <div id="build-controls">
            [I] Menu | [Left Click] Place | [Right Click] Remove | [R] Rotate | [P] Export World
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>Eliasentialverse</h1>
        <p>Welcome to the healthy cereal metaverse!</p>
        <div class="btn-group">
            <button class="btn" onclick="startGame('adventure')">Adventure Mode</button>
            <button class="btn btn-blue" onclick="startGame('builder')">Build Mode</button>
            <button class="btn btn-green" onclick="showLoadModal()">Load Custom World</button>
        </div>
    </div>

    <!-- Load Modal -->
    <div id="load-modal">
        <h2>Load Custom World</h2>
        <p>Paste your world code below:</p>
        <textarea id="world-data-input" placeholder='{"objects": [...]}'></textarea>
        <div class="btn-group">
            <button class="btn" onclick="loadCustomWorld()">Play World</button>
            <button class="btn" onclick="document.getElementById('load-modal').style.display='none'" style="background:#444; color:white;">Cancel</button>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="house-panel" class="export-mode" style="height: auto; min-height: 200px;">
         <!-- Reusing this container for Export UI dynamically -->
    </div>

    <!-- Panels -->
    <div id="shop-panel">
        <div class="panel-header">
            <span id="shop-title">Shop</span>
            <span class="close-btn" onclick="toggleShop(false)">X</span>
        </div>
        <div class="panel-content" id="shop-items"></div>
    </div>

    <!-- Scripts -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/PointerLockControls.js';

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let raycaster, mouseRaycaster;
        
        // Game State
        const state = {
            mode: 'menu', // 'adventure', 'builder', 'custom_play'
            coins: 0,
            inventory: [], // Adventure mode inventory
            placedItems: [],
            builderObjects: [], // Objects placed in builder mode
            inHouse: false,
            isEditing: false
        };

        // World Objects
        let interactables = [];
        let colliders = [];
        let collectibles = [];
        let ghostMesh = null;
        let ghostRotation = 0;

        // Assets / Item Database
        // Added 'builder_only' items for creative mode
        const itemsDB = [
            { id: 'lamp', name: 'Milk Carton Lamp', price: 10, color: 0xffffff, scale: [0.5, 1.5, 0.5], type: 'box' },
            { id: 'chair', name: 'Spoon Chair', price: 25, color: 0x8B4513, scale: [1, 1, 1], type: 'chair_shape' },
            { id: 'table', name: 'Wheat Table', price: 50, color: 0xDAA520, scale: [2, 1, 2], type: 'table_shape' },
            { id: 'plant', name: 'Healthy Fern', price: 15, color: 0x228B22, scale: [0.5, 2, 0.5], type: 'box' },
            { id: 'trophy', name: 'Golden Bowl', price: 100, color: 0xFFD700, scale: [0.8, 0.8, 0.8], type: 'sphere' },
            
            // Builder Blocks
            { id: 'block_brick', name: 'Brick Block', price: 0, color: 0xA52A2A, scale: [2, 2, 2], type: 'box', builder: true },
            { id: 'block_stone', name: 'Stone Block', price: 0, color: 0x808080, scale: [2, 2, 2], type: 'box', builder: true },
            { id: 'block_wood', name: 'Wood Planks', price: 0, color: 0xDEB887, scale: [4, 0.5, 4], type: 'box', builder: true },
            { id: 'block_grass', name: 'Grass Block', price: 0, color: 0x4CAF50, scale: [2, 2, 2], type: 'box', builder: true },
            { id: 'spawner_coin', name: 'Coin (50)', price: 0, color: 0xFFD700, scale: [1, 1, 1], type: 'coin', builder: true }
        ];

        // --- INITIALIZATION ---
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            // Expand shadow range for big custom worlds
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            scene.add(dirLight);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            
            controls.addEventListener('unlock', () => {
                if (!isUIOpen() && state.mode !== 'menu') {
                    // Pause menu logic could go here
                }
            });

            // Suppress annoying unhandled rejection for pointer lock security error
            window.addEventListener('unhandledrejection', (event) => {
                if (event.reason && event.reason.name === 'SecurityError') {
                    event.preventDefault();
                }
            });

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 2);
            mouseRaycaster = new THREE.Raycaster();
            window.interactionRaycaster = new THREE.Raycaster();

            // Default ground to start (so title screen isn't void)
            createGround(); 

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick); // Changed to mousedown for Right Click support
            window.addEventListener('resize', onWindowResize);

            // Export Functions to Window
            window.startGame = startGame;
            window.showLoadModal = () => document.getElementById('load-modal').style.display = 'flex';
            window.loadCustomWorld = parseAndLoadWorld;
            window.toggleShop = toggleShop;
            window.buyItem = buyItem;
            window.selectFurniture = selectFurniture;
            window.toggleHousePanel = toggleHousePanel;
        }

        // --- MODE MANAGEMENT ---

        function startGame(mode) {
            state.mode = mode;
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('mode-display').innerText = mode === 'builder' ? "Build Mode" : "Adventure";
            
            // Reset World
            clearWorld();
            createGround();

            if (mode === 'adventure') {
                createPlaza();
                createShop();
                createHouse();
                createParkour();
                generateCollectibles();
                document.getElementById('build-controls').style.display = 'none';
            } else if (mode === 'builder') {
                document.getElementById('build-controls').style.display = 'block';
                // In builder mode, we start empty (just ground)
                showNotification("Build Mode Started! Press 'I' for blocks.");
            }

            // Reset Player
            controls.getObject().position.set(0, 2, 0);
            
            // Fix: Add delay to pointer lock to prevent SecurityError due to DOM updates
            setTimeout(() => {
                try {
                    controls.lock();
                } catch(e) { console.log("Lock failed (retry via click)"); }
            }, 50);
        }

        function clearWorld() {
            // Remove everything except lights and camera
            const toRemove = [];
            scene.traverse(child => {
                if (child.isMesh || child.isGroup) {
                    if (child !== controls.getObject()) {
                        toRemove.push(child);
                    }
                }
            });
            toRemove.forEach(obj => scene.remove(obj));

            colliders = [];
            interactables = [];
            collectibles = [];
            state.builderObjects = [];
            state.coins = 0;
            state.inventory = [];
            updateHUD();
        }

        // --- WORLD GENERATION PRIMITIVES ---

        function createGround() {
            const geometry = new THREE.PlaneGeometry(200, 200);
            geometry.rotateX(-Math.PI / 2);
            
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const context = canvas.getContext('2d');
            context.fillStyle = '#4CAF50';
            context.fillRect(0,0,512,512);
            for(let i=0; i<5000; i++) {
                context.fillStyle = Math.random() > 0.5 ? '#45a049' : '#55b559';
                const x = Math.random()*512;
                const y = Math.random()*512;
                context.fillRect(x,y, 4, 4);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(20, 20);

            const material = new THREE.MeshStandardMaterial({ map: texture });
            const ground = new THREE.Mesh(geometry, material);
            ground.receiveShadow = true;
            scene.add(ground);
            colliders.push(ground); // Standard ground is always collidable

            // River (Visual only for now unless parkour added)
            const river = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 200),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 })
            );
            river.rotateX(-Math.PI/2);
            river.position.set(60, 0.05, 0);
            scene.add(river);
        }

        // --- BUILDER & CUSTOM LOADER LOGIC ---

        function parseAndLoadWorld() {
            const input = document.getElementById('world-data-input').value;
            try {
                const data = JSON.parse(input);
                startGame('custom_play');
                document.getElementById('load-modal').style.display = 'none';
                
                // Load Objects
                if (data.objects) {
                    data.objects.forEach(objData => {
                        const itemDef = itemsDB.find(i => i.id === objData.id);
                        if (itemDef) {
                            if (itemDef.type === 'coin') {
                                createCollectible(objData.pos.x, objData.pos.y, objData.pos.z, true);
                            } else {
                                const mesh = createItemMesh(itemDef, false);
                                mesh.position.set(objData.pos.x, objData.pos.y, objData.pos.z);
                                mesh.rotation.y = objData.rot;
                                scene.add(mesh);
                                colliders.push(mesh);
                            }
                        }
                    });
                }
                showNotification("Custom World Loaded!");
            } catch (e) {
                alert("Invalid World Data!");
            }
        }

        function exportWorld() {
            controls.unlock();
            const data = {
                version: 1,
                objects: state.builderObjects
            };
            const json = JSON.stringify(data);
            
            // Hijack Shop Panel for Export UI
            const panel = document.getElementById('shop-panel');
            panel.style.display = 'flex';
            panel.querySelector('.panel-header').innerHTML = `<span>Export World</span><span class="close-btn" onclick="toggleShop(false)">X</span>`;
            panel.querySelector('.panel-content').style.display = 'block';
            panel.querySelector('.panel-content').innerHTML = `
                <p>Copy this code and save it:</p>
                <textarea style="width:90%; height:200px;">${json}</textarea>
                <button class="btn" onclick="toggleShop(false)">Close</button>
            `;
        }

        // --- ADVENTURE MODE PREFABS ---
        
        function createPlaza() {
            // Central Fountain / Statue Area
            const baseGeo = new THREE.CylinderGeometry(5, 5, 1, 32);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.set(0, 0.5, 0);
            base.receiveShadow = true;
            scene.add(base);
            colliders.push(base);

            // Billboard
            const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 10);
            const pole = new THREE.Mesh(poleGeo, baseMat);
            pole.position.set(0, 5, 0);
            scene.add(pole);

            const boardGeo = new THREE.BoxGeometry(16, 8, 1);
            
            // Dynamic Canvas for Text
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FF9800'; // Brand Orange
            ctx.fillRect(0, 0, 1024, 512);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("ELIASENTIALVERSE", 512, 150);
            ctx.font = '40px Arial';
            ctx.fillText("Healthy Cereal for a Healthy Life!", 512, 250);
            
            const boardTex = new THREE.CanvasTexture(canvas);
            const boardMat = new THREE.MeshStandardMaterial({ map: boardTex });
            const board = new THREE.Mesh(boardGeo, boardMat);
            board.position.set(0, 10, 0);
            scene.add(board);
        }

        function createShop() {
            const shopGroup = new THREE.Group();
            shopGroup.position.set(-20, 0, -20);

            // Building
            const buildGeo = new THREE.BoxGeometry(15, 10, 15);
            const buildMat = new THREE.MeshStandardMaterial({ color: 0xFF5722 }); // Deep Orange
            const building = new THREE.Mesh(buildGeo, buildMat);
            building.position.y = 5;
            building.castShadow = true;
            building.receiveShadow = true;
            shopGroup.add(building);
            colliders.push(building); // Simple collision (can jump on roof)

            // Shop Keeper / Interaction Point
            const counterGeo = new THREE.BoxGeometry(4, 2, 2);
            const counterMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const counter = new THREE.Mesh(counterGeo, counterMat);
            counter.position.set(0, 1, 8); // Front of shop
            shopGroup.add(counter);

            // NPC (Cube style)
            const npcGeo = new THREE.BoxGeometry(1, 2, 1);
            const npcMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const npc = new THREE.Mesh(npcGeo, npcMat);
            npc.position.set(0, 2.5, 8.5);
            shopGroup.add(npc);

            // Interaction Zone
            const zone = new THREE.Mesh(
                new THREE.BoxGeometry(6, 6, 6),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            zone.position.set(0, 3, 8);
            zone.userData = { type: 'shop' };
            interactables.push(zone);
            shopGroup.add(zone);

            // Label
            const labelCanvas = document.createElement('canvas');
            const ctx = labelCanvas.getContext('2d');
            labelCanvas.width = 256; labelCanvas.height = 64;
            ctx.fillStyle = 'white';
            ctx.font = '40px Arial';
            ctx.fillText("SHOP", 10, 50);
            const labelTex = new THREE.CanvasTexture(labelCanvas);
            const label = new THREE.Mesh(new THREE.PlaneGeometry(5, 1.5), new THREE.MeshBasicMaterial({map: labelTex, transparent:true, side: THREE.DoubleSide}));
            label.position.set(0, 7, 8);
            shopGroup.add(label);

            scene.add(shopGroup);
        }

        function createHouse() {
            const houseGroup = new THREE.Group();
            houseGroup.position.set(-20, 0, 20);

            // Floor
            const floorGeo = new THREE.BoxGeometry(20, 0.5, 20);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xDEB887 }); // Wood
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.y = 0.25;
            floor.receiveShadow = true;
            houseGroup.add(floor);
            colliders.push(floor);

            // Walls (Open concept)
            const wallGeo = new THREE.BoxGeometry(1, 8, 20);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xFFFDD0 }); // Cream
            
            // Wall 1 (Left)
            const wall1 = new THREE.Mesh(wallGeo, wallMat);
            wall1.position.set(-9.5, 4, 0);
            houseGroup.add(wall1);

            // Wall 2 (Back)
            const wall2 = new THREE.Mesh(new THREE.BoxGeometry(20, 8, 1), wallMat);
            wall2.position.set(0, 4, -9.5);
            houseGroup.add(wall2);

            // Wall 3 (Right)
            const wall3 = new THREE.Mesh(wallGeo, wallMat);
            wall3.position.set(9.5, 4, 0);
            houseGroup.add(wall3);

            // Wall 4 (Front) - Split for door
            const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 1), wallMat);
            frontWallLeft.position.set(-6, 4, 9.5);
            houseGroup.add(frontWallLeft);

            const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 1), wallMat);
            frontWallRight.position.set(6, 4, 9.5);
            houseGroup.add(frontWallRight);

            // Door Header
            const doorHeader = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 1), wallMat);
            doorHeader.position.set(0, 7, 9.5);
            houseGroup.add(doorHeader);

            // Roof
            const roofGeo = new THREE.ConeGeometry(15, 6, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0xA52A2A });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 11;
            roof.rotation.y = Math.PI / 4;
            houseGroup.add(roof);

            // House Zone Trigger (Invisible box filling the house)
            const zone = new THREE.Mesh(
                new THREE.BoxGeometry(18, 8, 18),
                new THREE.MeshBasicMaterial({ visible: false, wireframe: true })
            );
            zone.position.set(0, 4, 0);
            zone.userData = { type: 'house_zone' };
            interactables.push(zone); // Not clickable, but we check distance to center manually in update
            houseGroup.add(zone);

            // Store house group reference for placing items relative to it
            window.houseGroup = houseGroup;
            scene.add(houseGroup);
        }

        function createParkour() {
             createPlatform(60, 2, -10);
             createPlatform(60, 4, 0);
             createPlatform(60, 6, 10);
             createCollectible(60, 8, 10, true);
        }
        function createPlatform(x,y,z) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(4,0.5,4), new THREE.MeshStandardMaterial({color:0xFFD700}));
            mesh.position.set(x,y,z);
            scene.add(mesh); colliders.push(mesh);
        }

        function generateCollectibles() {
             for(let i=0; i<10; i++) createCollectible((Math.random()-0.5)*50, 1, (Math.random()-0.5)*50);
        }

        function createCollectible(x, y, z, isBig = false) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(isBig?1:0.5, isBig?1:0.5, isBig?0.2:0.1), 
                new THREE.MeshStandardMaterial({color: 0xFFD700})
            );
            mesh.position.set(x, y, z);
            mesh.userData = { type: 'coin', value: isBig?50:10, rotationSpeed: 0.02 };
            scene.add(mesh);
            collectibles.push(mesh);
        }

        // --- ITEM PLACEMENT SYSTEM ---

        function createItemMesh(data, isGhost) {
            let geometry, material;
            
            if (data.type === 'chair_shape') geometry = new THREE.BoxGeometry(1, 1, 1);
            else if (data.type === 'table_shape') geometry = new THREE.BoxGeometry(2, 1, 1.5);
            else if (data.type === 'sphere') geometry = new THREE.SphereGeometry(0.5, 16, 16);
            else geometry = new THREE.BoxGeometry(1, 1, 1); // Default box

            geometry.scale(data.scale[0], data.scale[1], data.scale[2]);

            // Pivot shift
            geometry.computeBoundingBox();
            const height = geometry.boundingBox.max.y - geometry.boundingBox.min.y;
            geometry.translate(0, height / 2, 0);

            material = new THREE.MeshStandardMaterial({ 
                color: data.color, 
                transparent: isGhost, 
                opacity: isGhost ? 0.5 : 1.0,
                side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            const group = new THREE.Group();
            group.add(mesh);
            return group;
        }

        function renderBuilderMenu() {
            const container = document.getElementById('shop-items');
            container.innerHTML = '';
            
            // Show all items including builder blocks
            itemsDB.forEach(item => {
                const div = document.createElement('div');
                div.className = 'item-card';
                div.innerHTML = `
                    <div class="item-name">${item.name}</div>
                    <button class="buy-btn" onclick="event.stopPropagation(); selectFurniture('${item.id}')">Select</button>
                `;
                container.appendChild(div);
            });

            // Hijack Shop Panel for Builder UI
            const panel = document.getElementById('shop-panel');
            panel.querySelector('.panel-header').innerHTML = `<span>Builder Menu</span><span class="close-btn" onclick="toggleShop(false)">X</span>`;
            panel.style.display = 'flex';
            controls.unlock();
        }

        // --- INPUT & UPDATE ---

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += 30; canJump = false; break;
                case 'KeyE': interact(); break;
                case 'KeyI': 
                    if (state.mode === 'builder') renderBuilderMenu();
                    else if(state.inHouse) toggleHousePanel(!state.isEditing); 
                    break;
                case 'KeyR': if(state.isEditing || state.mode==='builder') rotateGhost(); break;
                case 'KeyP': if(state.mode === 'builder') exportWorld(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseClick(event) {
            // Right Click to Delete (Builder Mode)
            if (state.mode === 'builder' && event.button === 2) {
                if (controls.isLocked) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    mouseRaycaster.set(camera.position, camDir);
                    const intersects = mouseRaycaster.intersectObjects(colliders, true); // Recursive
                    
                    if (intersects.length > 0 && intersects[0].distance < 10) {
                        // Find the top-level group object to remove
                        let target = intersects[0].object;
                        while(target.parent && target.parent !== scene) {
                            target = target.parent;
                        }
                        
                        // Don't delete the ground
                        if (target !== colliders[0]) { 
                            scene.remove(target);
                            colliders = colliders.filter(c => c !== target);
                            
                            // Remove from data
                            const idx = state.builderObjects.findIndex(obj => 
                                Math.abs(obj.pos.x - target.position.x) < 0.1 && 
                                Math.abs(obj.pos.z - target.position.z) < 0.1
                            );
                            if(idx > -1) state.builderObjects.splice(idx, 1);
                        }
                    }
                }
            }

            // Left Click to Place
            else if (event.button === 0) {
                if ((state.isEditing || state.mode === 'builder') && ghostMesh && ghostMesh.visible) {
                    placeItem();
                } else if (!controls.isLocked && !isUIOpen() && state.mode !== 'menu') {
                    controls.lock();
                }
            }
        }

        function rotateGhost() {
            ghostRotation += Math.PI / 4;
        }

        function interact() {
            if (state.mode === 'adventure') {
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                window.interactionRaycaster.set(camera.position, camDir);
                const intersects = window.interactionRaycaster.intersectObjects(interactables);
                if (intersects.length > 0 && intersects[0].distance < 5) {
                    if (intersects[0].object.userData.type === 'shop') toggleShop(true);
                }
            }
        }

        function updatePhysics(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            controls.getObject().position.y += (velocity.y * delta); 

            raycaster.ray.origin.copy(controls.getObject().position);
            const intersections = raycaster.intersectObjects(colliders, true);
            
            if (intersections.length > 0) {
                if (intersections[0].distance < 2 && velocity.y < 0) {
                    velocity.y = Math.max(0, velocity.y);
                    controls.getObject().position.y = intersections[0].point.y + 2;
                    canJump = true;
                }
            }
            if (controls.getObject().position.y < 2) {
                velocity.y = 0;
                controls.getObject().position.y = 2;
                canJump = true;
            }
        }

        function updateLogic(time) {
            // Collectibles logic
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const c = collectibles[i];
                c.rotation.y += 0.02;
                if (controls.getObject().position.distanceTo(c.position) < 2) {
                    state.coins += c.userData.value;
                    updateHUD();
                    scene.remove(c);
                    collectibles.splice(i, 1);
                    showNotification(`Collected ${c.userData.value} Coins!`);
                }
            }

            // House logic only in adventure
            if (state.mode === 'adventure') {
                const p = controls.getObject().position;
                const inZone = p.x > -30 && p.x < -10 && p.z > 10 && p.z < 30;
                if (inZone && !state.inHouse) {
                    state.inHouse = true;
                    // FIX: Check for null to prevent crash
                    const hint = document.getElementById('edit-hint');
                    if (hint) hint.style.display = 'block'; 
                } else if (!inZone && state.inHouse) {
                    state.inHouse = false;
                    state.isEditing = false;
                    toggleHousePanel(false);
                    // FIX: Check for null
                    const hint = document.getElementById('edit-hint');
                    if (hint) hint.style.display = 'none';
                }
            }

            // Ghost Update
            if ((state.isEditing || state.mode === 'builder') && ghostMesh) {
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const targetPos = controls.getObject().position.clone().add(dir.multiplyScalar(5));
                targetPos.x = Math.round(targetPos.x * 2) / 2;
                targetPos.y = Math.max(0.5, targetPos.y); 
                targetPos.z = Math.round(targetPos.z * 2) / 2;
                ghostMesh.position.copy(targetPos);
                ghostMesh.rotation.y = ghostRotation;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            if (controls.isLocked) updatePhysics(delta);
            updateLogic(time/1000);
            prevTime = time;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateHUD() {
            document.getElementById('score-display').innerText = state.coins;
        }
        function showNotification(text) {
            const n = document.getElementById('notification');
            n.innerText = text;
            n.classList.add('show');
            setTimeout(() => n.classList.remove('show'), 3000);
        }
        function isUIOpen() {
            return document.getElementById('shop-panel').style.display === 'flex' ||
                   document.getElementById('load-modal').style.display === 'flex';
        }

        // --- SHARED UI FUNCTIONS ---
        // (Adapted from previous logic to work with both modes)
        
        function renderShopItems() {
            const container = document.getElementById('shop-items');
            container.innerHTML = '';
            
            // Filter out builder-only items for the adventure shop
            const shopItems = itemsDB.filter(item => !item.builder);

            shopItems.forEach(item => {
                const div = document.createElement('div');
                div.className = 'item-card';
                div.innerHTML = `
                    <div class="item-name">${item.name}</div>
                    <div class="item-price">${item.price} Coins</div>
                    <button class="buy-btn" onclick="event.stopPropagation(); buyItem('${item.id}')">Buy</button>
                `;
                container.appendChild(div);
                
                // Check affordability
                const btn = div.querySelector('button');
                if (state.coins < item.price) btn.disabled = true;
            });
        }

        function toggleShop(show) {
            const panel = document.getElementById('shop-panel');
            if (show) {
                // Ensure we are in shop mode visually (reset title if Builder mode changed it)
                const title = document.getElementById('shop-title');
                if(title) title.innerText = "Shop";
                
                renderShopItems();
                panel.style.display = 'flex';
                controls.unlock();
            } else {
                panel.style.display = 'none';
                // Fix: Add delay when closing shop to allow UI to disappear before locking
                setTimeout(() => { controls.lock(); }, 50);
            }
        }

        function buyItem(id) {
            // Only for adventure shop
            const item = itemsDB.find(i => i.id === id);
            if (state.coins >= item.price) {
                state.coins -= item.price;
                state.inventory.push(id);
                updateHUD();
                // Refresh shop list to update disabled states
                renderShopItems();
                showNotification(`Bought ${item.name}!`);
            }
        }

        function toggleHousePanel(show) {
            // Adventure mode inventory only
            state.isEditing = show;
            const panel = document.getElementById('house-panel');
            // Reusing this panel div for export logic messiness, so ensure clean state
            panel.innerHTML = `
                <div class="panel-header"><span>Inventory</span><span class="close-btn" onclick="toggleHousePanel(false)">X</span></div>
                <div class="panel-content" id="inventory-items"></div>
            `;
            
            if (show) {
                // Render Inventory
                const container = panel.querySelector('#inventory-items');
                if (state.inventory.length === 0) container.innerHTML = 'Empty Inventory';
                else {
                    state.inventory.forEach(id => {
                        const item = itemsDB.find(i => i.id === id);
                        container.innerHTML += `<div class='item-card'>${item.name} <button onclick="event.stopPropagation(); selectFurniture('${id}')">Place</button></div>`;
                    });
                }
                panel.style.display = 'flex';
                controls.unlock();
            } else {
                panel.style.display = 'none';
                if(ghostMesh) { scene.remove(ghostMesh); ghostMesh = null; }
                // Fix: Add delay when closing inventory to allow UI to disappear before locking
                setTimeout(() => { controls.lock(); }, 50);
            }
        }

        // Select Item (Shared by Inventory and Builder)
        function selectFurniture(id) {
            document.getElementById('shop-panel').style.display = 'none';
            document.getElementById('house-panel').style.display = 'none';
            // Fix: No need to lock immediately here, the next click places it, or we lock for placement mode
            controls.lock();
            
            if (ghostMesh) scene.remove(ghostMesh);
            const itemData = itemsDB.find(i => i.id === id);
            ghostMesh = createItemMesh(itemData, true);
            ghostMesh.userData.itemId = id;
            
            // Initial pos
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            ghostMesh.position.copy(controls.getObject().position.clone().add(dir.multiplyScalar(5)));
            scene.add(ghostMesh);
            
            // Set flag
            if(state.mode === 'adventure') state.isEditing = true;
        }

        function placeItem() {
            if (!ghostMesh) return;
            const id = ghostMesh.userData.itemId;
            
            // In adventure, remove from inventory
            if (state.mode === 'adventure') {
                const index = state.inventory.indexOf(id);
                if (index > -1) state.inventory.splice(index, 1);
                else {
                    // Out of items
                    scene.remove(ghostMesh); ghostMesh = null;
                    state.isEditing = false;
                    return;
                }
            }

            const itemData = itemsDB.find(i => i.id === id);
            
            // Special case for coins in Builder
            if (itemData.type === 'coin') {
                 createCollectible(ghostMesh.position.x, ghostMesh.position.y, ghostMesh.position.z, true);
                 // Track for export
                 state.builderObjects.push({ 
                    id: id, 
                    pos: ghostMesh.position.clone(), 
                    rot: ghostMesh.rotation.y 
                });
            } else {
                const mesh = createItemMesh(itemData, false);
                mesh.position.copy(ghostMesh.position);
                mesh.rotation.y = ghostMesh.rotation.y;
                scene.add(mesh);
                colliders.push(mesh);
                
                // Track for export
                state.builderObjects.push({ 
                    id: id, 
                    pos: mesh.position.clone(), 
                    rot: mesh.rotation.y 
                });
            }

            // In Adventure mode, reopen inventory. In Builder, keep ghost.
            if (state.mode === 'adventure') {
                scene.remove(ghostMesh); ghostMesh = null;
                controls.unlock();
                toggleHousePanel(true);
            }
        }

    </script>
</body>
</html>
