<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pipisian Geometry Simulator</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#7dd3fc;--muted:#94a3b8;--white:#e6eef8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;gap:16px;padding:16px;background:linear-gradient(180deg,#071028 0%, #07121a 60%);color:var(--white)}
    .sidebar{width:360px;max-width:40%;background:rgba(255,255,255,0.03);padding:16px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    .title{font-size:18px;font-weight:700;margin-bottom:8px}
    .muted{color:var(--muted);font-size:13px}
    .canvas-wrap{flex:1;display:flex;flex-direction:column;gap:12px}
    canvas{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:10px;box-shadow:inset 0 0 120px rgba(0,0,0,0.6);}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px}
    button,input,select{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--white);font-size:13px}
    .small{font-size:12px;padding:6px 8px}
    .tool-list{display:flex;flex-direction:column;gap:8px;margin-top:12px}
    .tool{display:flex;gap:8px;align-items:center}
    label{display:flex;gap:8px;align-items:center}
    .footer{margin-top:12px;color:var(--muted);font-size:12px}
    .status{margin-top:10px;color:var(--muted);font-size:13px}
    .hr{height:1px;background:rgba(255,255,255,0.03);margin:10px 0;border-radius:2px}
    .row{display:flex;gap:8px}
    .json-box{width:100%;height:90px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;color:var(--white);font-family:monospace;font-size:12px;overflow:auto}
    .hint{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="title">Pipisian Geometry Simulator</div>
    <div class="muted">Everything is an oval with width:height = 1.5 : 1 (major/minor = 1.5)</div>

    <div class="hr"></div>

    <div class="tool-list">
      <div class="tool"><button id="tool_add" class="small">Add Oval</button><button id="tool_chain" class="small">Tangent Chain</button><button id="tool_select" class="small">Select/Move</button></div>

      <div class="row">
        <label>Radius r: <input id="r_input" type="number" min="2" value="40" style="width:84px"></label>
        <label>Orientation: <input id="angle_input" type="number" value="0" style="width:72px">Â°</label>
      </div>

      <div class="row">
        <label>Alpha (opacity): <input id="alpha" type="range" min="0" max="1" step="0.01" value="0.9"></label>
      </div>

      <div class="row">
        <button id="delete_btn" class="small">Delete Selected</button>
        <button id="clear_btn" class="small">Clear</button>
      </div>

      <div class="hr"></div>

      <div>
        <div class="muted">Tangent chain tool:</div>
        <div class="hint">Click a starting oval, drag to set direction, release to place next tangent oval with chosen r &amp; orientation. Repeat for chains.</div>
      </div>

      <div class="hr"></div>

      <div>
        <div class="muted">Export / Import</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="export_btn" class="small">Export JSON</button>
          <button id="import_btn" class="small">Import JSON</button>
        </div>
        <textarea id="json_area" class="json-box" placeholder='Paste scene JSON here to import'></textarea>
      </div>

      <div class="hr"></div>

      <div class="status" id="status">Mode: <strong id="mode_label">Add Oval</strong></div>
      <div class="footer">Controls: Left-click to add/select, drag to move, rotate with rotate-handle, shift+drag for precision.</div>
    </div>
  </div>

  <div class="canvas-wrap">
    <canvas id="c" width="1200" height="800"></canvas>
    <div style="display:flex;gap:8px;align-items:center">
      <div class="muted">Snap to grid:</div>
      <input id="snap_chk" type="checkbox">
      <div class="muted">Show centers</div>
      <input id="centers_chk" type="checkbox" checked>
      <div style="flex:1"></div>
      <div class="muted">Pipisian rule enforced: <strong>1.5 : 1</strong></div>
    </div>
  </div>

<script>
// Pipisian Geometry Simulator - Single HTML file
// Author: generated by assistant
// Core idea: all ovals have width:height = 1.5 : 1 => a = 1.5*r, b = r in ellipse parametrization.

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// UI elements
const toolAdd = document.getElementById('tool_add');
const toolChain = document.getElementById('tool_chain');
const toolSelect = document.getElementById('tool_select');
const modeLabel = document.getElementById('mode_label');
const rInput = document.getElementById('r_input');
const angleInput = document.getElementById('angle_input');
const alphaInput = document.getElementById('alpha');
const deleteBtn = document.getElementById('delete_btn');
const clearBtn = document.getElementById('clear_btn');
const exportBtn = document.getElementById('export_btn');
const importBtn = document.getElementById('import_btn');
const jsonArea = document.getElementById('json_area');
const snapChk = document.getElementById('snap_chk');
const centersChk = document.getElementById('centers_chk');

let mode = 'add'; // 'add' | 'chain' | 'select'
function setMode(m){ mode = m; modeLabel.textContent = (m==='add'?'Add Oval':(m==='chain'?'Tangent Chain':'Select/Move')); }

toolAdd.onclick = ()=> setMode('add');
toolChain.onclick = ()=> setMode('chain');
toolSelect.onclick = ()=> setMode('select');

// Scene data: array of ovals
// oval: {x,y,r,phi,alpha,id}
let ovals = [];
let selected = null;
let nextId = 1;

// Constants: pipisian ratio
const ratio = 1.5; // a = ratio * r, b = r

function addOval(x,y,r,phi=0,alpha=0.9){
  const id = nextId++;
  const o = {x,y,r:Math.max(2,r),phi,alpha,id};
  ovals.push(o);
  return o;
}

// helpers
function draw(){
  ctx.clearRect(0,0,W,H);
  // background grid
  drawGrid();
  // pipilines between centers (if more than 1)
  drawPipilines();
  // draw ovals
  for(const o of ovals){ drawOval(o); }
  // draw selection
  if(selected){ drawSelection(selected); }
}

function drawGrid(){
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#9fb7c8';
  for(let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();
}

function drawOval(o){
  ctx.save();
  ctx.translate(o.x,o.y);
  ctx.rotate(o.phi*Math.PI/180);
  const a = ratio*o.r, b = o.r;
  ctx.beginPath();
  ctx.ellipse(0,0,a,b,0,0,Math.PI*2);
  ctx.fillStyle = `rgba(125,211,252,${o.alpha})`;
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.restore();

  if(centersChk.checked){
    ctx.beginPath(); ctx.arc(o.x,o.y,3,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fill();
  }
}

function drawSelection(o){
  // bounding box
  ctx.save();
  ctx.translate(o.x,o.y);
  ctx.rotate(o.phi*Math.PI/180);
  const a = ratio*o.r, b = o.r;
  ctx.beginPath(); ctx.ellipse(0,0,a+6,b+6,0,0,Math.PI*2);
  ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth=2; ctx.setLineDash([6,6]); ctx.stroke();
  // rotate handle
  ctx.setLineDash([]);
  ctx.beginPath(); ctx.moveTo(a+10,0); ctx.lineTo(a+28,0); ctx.strokeStyle='rgba(125,211,252,0.9)'; ctx.lineWidth=3; ctx.stroke();
  ctx.beginPath(); ctx.arc(a+32,0,8,0,Math.PI*2); ctx.fillStyle='rgba(125,211,252,0.95)'; ctx.fill(); ctx.restore();
}

function drawPipilines(){
  if(ovals.length<2) return;
  ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.12)';
  ctx.beginPath();
  for(let i=0;i<ovals.length;i++){
    const p = ovals[i];
    if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke(); ctx.restore();
}

// hit test
function hitTest(x,y){
  for(let i=ovals.length-1;i>=0;i--){
    const o = ovals[i];
    // transform point to oval's local coords
    const dx = x - o.x, dy = y - o.y;
    const th = -o.phi*Math.PI/180;
    const lx = dx*Math.cos(th) - dy*Math.sin(th);
    const ly = dx*Math.sin(th) + dy*Math.cos(th);
    const a = ratio*o.r, b = o.r;
    if((lx*lx)/(a*a) + (ly*ly)/(b*b) <= 1) return o;
  }
  return null;
}

// support function approximation: distance from center to boundary in direction u (unit vector)
function supportDistance(o, ux, uy){
  // sample many angles t on ellipse param (cos t, sin t)
  const a = ratio*o.r, b = o.r;
  let best = -Infinity;
  const cosPhi = Math.cos(o.phi*Math.PI/180), sinPhi = Math.sin(o.phi*Math.PI/180);
  for(let i=0;i<360;i+=4){
    const t = i*Math.PI/180;
    const vx = a*Math.cos(t), vy = b*Math.sin(t);
    // rotate by phi
    const rx = cosPhi*vx - sinPhi*vy;
    const ry = sinPhi*vx + cosPhi*vy;
    const proj = rx*ux + ry*uy;
    if(proj>best) best = proj;
  }
  return best; // approximate
}

// function to compute center for next oval tangent to source along direction u (unit vector)
function computeTangentCenter(source, nextR, nextPhi, ux, uy){
  const s1 = supportDistance(source, ux, uy);
  // for second, support with opposite direction
  const tmp = {x:0,y:0,r:nextR,phi:nextPhi};
  const s2 = supportDistance(tmp, -ux, -uy);
  const dist = s1 + s2;
  return {x: source.x + ux*dist, y: source.y + uy*dist};
}

// canvas interactions
let isDown = false, dragStart = null, dragMode = null;
let chainStart = null, chainDir = null;

canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  isDown = true; dragStart = {x,y};

  if(mode==='add'){
    if(e.shiftKey){ // precision: don't snap
      const r = parseFloat(rInput.value);
      const phi = parseFloat(angleInput.value);
      const a = addOval(x,y,r,phi,parseFloat(alphaInput.value));
      selected = a;
      draw();
    } else {
      const r = parseFloat(rInput.value);
      const phi = parseFloat(angleInput.value);
      const s = snapChk.checked ? snapToGrid(x,y) : {x,y};
      const a = addOval(s.x,s.y,r,phi,parseFloat(alphaInput.value));
      selected = a;
      draw();
    }
  } else if(mode==='select'){
    const hit = hitTest(x,y);
    if(hit){ selected = hit; dragMode='move'; } else { selected=null; }
    draw();
  } else if(mode==='chain'){
    // if clicked on existing oval, prepare chain
    const hit = hitTest(x,y);
    if(hit){ chainStart = hit; chainDir = null; selected = hit; dragMode='chain'; }
  }
});

canvas.addEventListener('mousemove', (e)=>{
  if(!isDown) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const dx = x-dragStart.x, dy = y-dragStart.y;

  if(mode==='select' && dragMode==='move' && selected){
    selected.x = (snapChk.checked ? snapToGrid(selected.x+dx,selected.y+dy).x : selected.x+dx);
    selected.y = (snapChk.checked ? snapToGrid(selected.x,selected.y+dy).y : selected.y+dy);
    dragStart = {x,y}; draw();
  }

  if(mode==='chain' && dragMode==='chain' && chainStart){
    // show preview direction
    chainDir = {x: x - chainStart.x, y: y - chainStart.y};
    draw();
    // draw preview arrow
    ctx.save(); ctx.beginPath(); ctx.moveTo(chainStart.x,chainStart.y); ctx.lineTo(x,y); ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=2; ctx.setLineDash([6,4]); ctx.stroke(); ctx.restore();
  }
});

canvas.addEventListener('mouseup', (e)=>{
  isDown = false;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  if(mode==='select'){ dragMode=null; }
  if(mode==='chain' && dragMode==='chain' && chainStart && chainDir){
    // compute unit vector
    const L = Math.hypot(chainDir.x, chainDir.y) || 1;
    const ux = chainDir.x / L, uy = chainDir.y / L;
    const r = parseFloat(rInput.value);
    const phi = parseFloat(angleInput.value);
    const center = computeTangentCenter(chainStart, r, phi, ux, uy);
    const o = addOval(center.x, center.y, r, phi, parseFloat(alphaInput.value));
    selected = o;
    // auto-chain: new source
    chainStart = o; chainDir = null; dragMode=null;
    draw();
  }
});

// rotate handle: double click on handle to rotate selected
canvas.addEventListener('dblclick', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  if(!selected) return;
  // check if dblclick near rotate handle
  const a = ratio*selected.r;
  const hx = selected.x + Math.cos(selected.phi*Math.PI/180)*(a+32);
  const hy = selected.y + Math.sin(selected.phi*Math.PI/180)*(a+32);
  if(Math.hypot(hx-x,hy-y) < 16){
    // rotate 15 degrees
    selected.phi = (selected.phi + 15) % 360; angleInput.value = selected.phi; draw();
  }
});

// sync UI when selecting an oval
canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const hit = hitTest(x,y);
  if(hit){ selected = hit; rInput.value = hit.r; angleInput.value = hit.phi; alphaInput.value = hit.alpha; draw(); }
});

// UI actions
rInput.addEventListener('change', ()=>{ if(selected) { selected.r = Math.max(2,parseFloat(rInput.value)); draw(); } });
angleInput.addEventListener('change', ()=>{ if(selected){ selected.phi = parseFloat(angleInput.value); draw(); } });
alphaInput.addEventListener('input', ()=>{ if(selected){ selected.alpha = parseFloat(alphaInput.value); draw(); } });

deleteBtn.addEventListener('click', ()=>{ if(selected){ ovals = ovals.filter(o=>o!==selected); selected=null; draw(); } });
clearBtn.addEventListener('click', ()=>{ ovals = []; selected=null; draw(); });

exportBtn.addEventListener('click', ()=>{
  const data = JSON.stringify({ovals,ratio},null,2);
  jsonArea.value = data;
});

importBtn.addEventListener('click', ()=>{
  try{ const obj = JSON.parse(jsonArea.value); if(obj.ovals){ ovals = obj.ovals.map(o=>({...o})); nextId = Math.max(1,...ovals.map(o=>o.id||0))+1; draw(); } }
  catch(err){ alert('Invalid JSON'); }
});

// snapping
function snapToGrid(x,y){
  if(typeof y==='undefined') return {x: Math.round(x/8)*8, y: Math.round(x/8)*8};
  return {x: Math.round(x/8)*8, y: Math.round(y/8)*8};
}

// resize
window.addEventListener('resize', ()=>{
  // keep canvas size fixed for simplicity, or adapt
});

// initial demo scene
addOval(220,180,40, -8, 0.9);
addOval(400,260,36, 12, 0.85);
addOval(620,160,56, -22, 0.8);
addOval(820,340,32, 48, 0.9);

setMode('add'); draw();

// quick helpers to export image
function downloadPNG(){
  const link = document.createElement('a');
  link.download = 'pipisian_scene.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if(e.key==='Delete'){ if(selected){ ovals = ovals.filter(o=>o!==selected); selected=null; draw(); } }
  if(e.ctrlKey && e.key==='s'){ e.preventDefault(); downloadPNG(); }
});

</script>
</body>
</html>
